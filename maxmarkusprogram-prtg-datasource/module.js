/* [create-plugin] version: 5.13.0 */
define(["@grafana/data", "@grafana/runtime", "@grafana/ui", "lodash", "module", "react", "rxjs"], ((e, t, r, n, o, i, s) => (() => { "use strict"; var a = { 781: t => { t.exports = e }, 531: e => { e.exports = t }, 7: e => { e.exports = r }, 241: e => { e.exports = n }, 308: e => { e.exports = o }, 959: e => { e.exports = i }, 269: e => { e.exports = s } }, l = {}; function c(e) { var t = l[e]; if (void 0 !== t) return t.exports; var r = l[e] = { exports: {} }; return a[e](r, r.exports, c), r.exports } c.n = e => { var t = e && e.__esModule ? () => e.default : () => e; return c.d(t, { a: t }), t }, c.d = (e, t) => { for (var r in t) c.o(t, r) && !c.o(e, r) && Object.defineProperty(e, r, { enumerable: !0, get: t[r] }) }, c.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), c.r = e => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }, c.p = "public/plugins/maxmarkusprogram-prtg-datasource/"; var u = {}; c.r(u), c.d(u, { plugin: () => Sr }); var d = {}; c.r(d), c.d(d, { hasBrowserEnv: () => Ne, hasStandardBrowserEnv: () => je, hasStandardBrowserWebWorkerEnv: () => Ce, navigator: () => Le, origin: () => De }); var p = c(308), m = c.n(p); c.p = m() && m().uri ? m().uri.slice(0, m().uri.lastIndexOf("/") + 1) : "public/plugins/maxmarkusprogram-prtg-datasource/"; var h = c(781), f = c(531), g = c(241), v = c.n(g); function y(e, t) { return function () { return e.apply(t, arguments) } } const { toString: b } = Object.prototype, { getPrototypeOf: S } = Object, w = (E = Object.create(null), e => { const t = b.call(e); return E[t] || (E[t] = t.slice(8, -1).toLowerCase()) }); var E; const T = e => (e = e.toLowerCase(), t => w(t) === e), O = e => t => typeof t === e, { isArray: P } = Array, R = O("undefined"); const N = T("ArrayBuffer"); const L = O("string"), j = O("function"), C = O("number"), D = e => null !== e && "object" == typeof e, A = e => { if ("object" !== w(e)) return !1; const t = S(e); return !(null !== t && t !== Object.prototype && null !== Object.getPrototypeOf(t) || Symbol.toStringTag in e || Symbol.iterator in e) }, F = T("Date"), _ = T("File"), x = T("Blob"), I = T("FileList"), k = T("URLSearchParams"), [U, q, M, $] = ["ReadableStream", "Request", "Response", "Headers"].map(T); function B(e, t, { allOwnKeys: r = !1 } = {}) { if (null == e) return; let n, o; if ("object" != typeof e && (e = [e]), P(e)) for (n = 0, o = e.length; n < o; n++)t.call(null, e[n], n, e); else { const o = r ? Object.getOwnPropertyNames(e) : Object.keys(e), i = o.length; let s; for (n = 0; n < i; n++)s = o[n], t.call(null, e[s], s, e) } } function G(e, t) { t = t.toLowerCase(); const r = Object.keys(e); let n, o = r.length; for (; o-- > 0;)if (n = r[o], t === n.toLowerCase()) return n; return null } const V = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : global, W = e => !R(e) && e !== V; const z = (H = "undefined" != typeof Uint8Array && S(Uint8Array), e => H && e instanceof H); var H; const Q = T("HTMLFormElement"), J = (({ hasOwnProperty: e }) => (t, r) => e.call(t, r))(Object.prototype), K = T("RegExp"), X = (e, t) => { const r = Object.getOwnPropertyDescriptors(e), n = {}; B(r, ((r, o) => { let i; !1 !== (i = t(r, o, e)) && (n[o] = i || r) })), Object.defineProperties(e, n) }, Z = "abcdefghijklmnopqrstuvwxyz", Y = "0123456789", ee = { DIGIT: Y, ALPHA: Z, ALPHA_DIGIT: Z + Z.toUpperCase() + Y }; const te = T("AsyncFunction"), re = (ne = "function" == typeof setImmediate, oe = j(V.postMessage), ne ? setImmediate : oe ? (ie = `axios@${Math.random()}`, se = [], V.addEventListener("message", (({ source: e, data: t }) => { e === V && t === ie && se.length && se.shift()() }), !1), e => { se.push(e), V.postMessage(ie, "*") }) : e => setTimeout(e)); var ne, oe, ie, se; const ae = "undefined" != typeof queueMicrotask ? queueMicrotask.bind(V) : "undefined" != typeof process && process.nextTick || re, le = { isArray: P, isArrayBuffer: N, isBuffer: function (e) { return null !== e && !R(e) && null !== e.constructor && !R(e.constructor) && j(e.constructor.isBuffer) && e.constructor.isBuffer(e) }, isFormData: e => { let t; return e && ("function" == typeof FormData && e instanceof FormData || j(e.append) && ("formdata" === (t = w(e)) || "object" === t && j(e.toString) && "[object FormData]" === e.toString())) }, isArrayBufferView: function (e) { let t; return t = "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e) : e && e.buffer && N(e.buffer), t }, isString: L, isNumber: C, isBoolean: e => !0 === e || !1 === e, isObject: D, isPlainObject: A, isReadableStream: U, isRequest: q, isResponse: M, isHeaders: $, isUndefined: R, isDate: F, isFile: _, isBlob: x, isRegExp: K, isFunction: j, isStream: e => D(e) && j(e.pipe), isURLSearchParams: k, isTypedArray: z, isFileList: I, forEach: B, merge: function e() { const { caseless: t } = W(this) && this || {}, r = {}, n = (n, o) => { const i = t && G(r, o) || o; A(r[i]) && A(n) ? r[i] = e(r[i], n) : A(n) ? r[i] = e({}, n) : P(n) ? r[i] = n.slice() : r[i] = n }; for (let e = 0, t = arguments.length; e < t; e++)arguments[e] && B(arguments[e], n); return r }, extend: (e, t, r, { allOwnKeys: n } = {}) => (B(t, ((t, n) => { r && j(t) ? e[n] = y(t, r) : e[n] = t }), { allOwnKeys: n }), e), trim: e => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""), stripBOM: e => (65279 === e.charCodeAt(0) && (e = e.slice(1)), e), inherits: (e, t, r, n) => { e.prototype = Object.create(t.prototype, n), e.prototype.constructor = e, Object.defineProperty(e, "super", { value: t.prototype }), r && Object.assign(e.prototype, r) }, toFlatObject: (e, t, r, n) => { let o, i, s; const a = {}; if (t = t || {}, null == e) return t; do { for (o = Object.getOwnPropertyNames(e), i = o.length; i-- > 0;)s = o[i], n && !n(s, e, t) || a[s] || (t[s] = e[s], a[s] = !0); e = !1 !== r && S(e) } while (e && (!r || r(e, t)) && e !== Object.prototype); return t }, kindOf: w, kindOfTest: T, endsWith: (e, t, r) => { e = String(e), (void 0 === r || r > e.length) && (r = e.length), r -= t.length; const n = e.indexOf(t, r); return -1 !== n && n === r }, toArray: e => { if (!e) return null; if (P(e)) return e; let t = e.length; if (!C(t)) return null; const r = new Array(t); for (; t-- > 0;)r[t] = e[t]; return r }, forEachEntry: (e, t) => { const r = (e && e[Symbol.iterator]).call(e); let n; for (; (n = r.next()) && !n.done;) { const r = n.value; t.call(e, r[0], r[1]) } }, matchAll: (e, t) => { let r; const n = []; for (; null !== (r = e.exec(t));)n.push(r); return n }, isHTMLForm: Q, hasOwnProperty: J, hasOwnProp: J, reduceDescriptors: X, freezeMethods: e => { X(e, ((t, r) => { if (j(e) && -1 !== ["arguments", "caller", "callee"].indexOf(r)) return !1; const n = e[r]; j(n) && (t.enumerable = !1, "writable" in t ? t.writable = !1 : t.set || (t.set = () => { throw Error("Can not rewrite read-only method '" + r + "'") })) })) }, toObjectSet: (e, t) => { const r = {}, n = e => { e.forEach((e => { r[e] = !0 })) }; return P(e) ? n(e) : n(String(e).split(t)), r }, toCamelCase: e => e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, (function (e, t, r) { return t.toUpperCase() + r })), noop: () => { }, toFiniteNumber: (e, t) => null != e && Number.isFinite(e = +e) ? e : t, findKey: G, global: V, isContextDefined: W, ALPHABET: ee, generateString: (e = 16, t = ee.ALPHA_DIGIT) => { let r = ""; const { length: n } = t; for (; e--;)r += t[Math.random() * n | 0]; return r }, isSpecCompliantForm: function (e) { return !!(e && j(e.append) && "FormData" === e[Symbol.toStringTag] && e[Symbol.iterator]) }, toJSONObject: e => { const t = new Array(10), r = (e, n) => { if (D(e)) { if (t.indexOf(e) >= 0) return; if (!("toJSON" in e)) { t[n] = e; const o = P(e) ? [] : {}; return B(e, ((e, t) => { const i = r(e, n + 1); !R(i) && (o[t] = i) })), t[n] = void 0, o } } return e }; return r(e, 0) }, isAsyncFn: te, isThenable: e => e && (D(e) || j(e)) && j(e.then) && j(e.catch), setImmediate: re, asap: ae }; function ce(e, t, r, n, o) { Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = (new Error).stack, this.message = e, this.name = "AxiosError", t && (this.code = t), r && (this.config = r), n && (this.request = n), o && (this.response = o, this.status = o.status ? o.status : null) } le.inherits(ce, Error, { toJSON: function () { return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: le.toJSONObject(this.config), code: this.code, status: this.status } } }); const ue = ce.prototype, de = {};["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach((e => { de[e] = { value: e } })), Object.defineProperties(ce, de), Object.defineProperty(ue, "isAxiosError", { value: !0 }), ce.from = (e, t, r, n, o, i) => { const s = Object.create(ue); return le.toFlatObject(e, s, (function (e) { return e !== Error.prototype }), (e => "isAxiosError" !== e)), ce.call(s, e.message, t, r, n, o), s.cause = e, s.name = e.name, i && Object.assign(s, i), s }; const pe = ce; function me(e) { return le.isPlainObject(e) || le.isArray(e) } function he(e) { return le.endsWith(e, "[]") ? e.slice(0, -2) : e } function fe(e, t, r) { return e ? e.concat(t).map((function (e, t) { return e = he(e), !r && t ? "[" + e + "]" : e })).join(r ? "." : "") : t } const ge = le.toFlatObject(le, {}, null, (function (e) { return /^is[A-Z]/.test(e) })); const ve = function (e, t, r) { if (!le.isObject(e)) throw new TypeError("target must be an object"); t = t || new FormData; const n = (r = le.toFlatObject(r, { metaTokens: !0, dots: !1, indexes: !1 }, !1, (function (e, t) { return !le.isUndefined(t[e]) }))).metaTokens, o = r.visitor || c, i = r.dots, s = r.indexes, a = (r.Blob || "undefined" != typeof Blob && Blob) && le.isSpecCompliantForm(t); if (!le.isFunction(o)) throw new TypeError("visitor must be a function"); function l(e) { if (null === e) return ""; if (le.isDate(e)) return e.toISOString(); if (!a && le.isBlob(e)) throw new pe("Blob is not supported. Use a Buffer instead."); return le.isArrayBuffer(e) || le.isTypedArray(e) ? a && "function" == typeof Blob ? new Blob([e]) : Buffer.from(e) : e } function c(e, r, o) { let a = e; if (e && !o && "object" == typeof e) if (le.endsWith(r, "{}")) r = n ? r : r.slice(0, -2), e = JSON.stringify(e); else if (le.isArray(e) && function (e) { return le.isArray(e) && !e.some(me) }(e) || (le.isFileList(e) || le.endsWith(r, "[]")) && (a = le.toArray(e))) return r = he(r), a.forEach((function (e, n) { !le.isUndefined(e) && null !== e && t.append(!0 === s ? fe([r], n, i) : null === s ? r : r + "[]", l(e)) })), !1; return !!me(e) || (t.append(fe(o, r, i), l(e)), !1) } const u = [], d = Object.assign(ge, { defaultVisitor: c, convertValue: l, isVisitable: me }); if (!le.isObject(e)) throw new TypeError("data must be an object"); return function e(r, n) { if (!le.isUndefined(r)) { if (-1 !== u.indexOf(r)) throw Error("Circular reference detected in " + n.join(".")); u.push(r), le.forEach(r, (function (r, i) { !0 === (!(le.isUndefined(r) || null === r) && o.call(t, r, le.isString(i) ? i.trim() : i, n, d)) && e(r, n ? n.concat(i) : [i]) })), u.pop() } }(e), t }; function ye(e) { const t = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" }; return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, (function (e) { return t[e] })) } function be(e, t) { this._pairs = [], e && ve(e, this, t) } const Se = be.prototype; Se.append = function (e, t) { this._pairs.push([e, t]) }, Se.toString = function (e) { const t = e ? function (t) { return e.call(this, t, ye) } : ye; return this._pairs.map((function (e) { return t(e[0]) + "=" + t(e[1]) }), "").join("&") }; const we = be; function Ee(e) { return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]") } function Te(e, t, r) { if (!t) return e; const n = r && r.encode || Ee; le.isFunction(r) && (r = { serialize: r }); const o = r && r.serialize; let i; if (i = o ? o(t, r) : le.isURLSearchParams(t) ? t.toString() : new we(t, r).toString(n), i) { const t = e.indexOf("#"); -1 !== t && (e = e.slice(0, t)), e += (-1 === e.indexOf("?") ? "?" : "&") + i } return e } const Oe = class { constructor() { this.handlers = [] } use(e, t, r) { return this.handlers.push({ fulfilled: e, rejected: t, synchronous: !!r && r.synchronous, runWhen: r ? r.runWhen : null }), this.handlers.length - 1 } eject(e) { this.handlers[e] && (this.handlers[e] = null) } clear() { this.handlers && (this.handlers = []) } forEach(e) { le.forEach(this.handlers, (function (t) { null !== t && e(t) })) } }, Pe = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 }, Re = { isBrowser: !0, classes: { URLSearchParams: "undefined" != typeof URLSearchParams ? URLSearchParams : we, FormData: "undefined" != typeof FormData ? FormData : null, Blob: "undefined" != typeof Blob ? Blob : null }, protocols: ["http", "https", "file", "blob", "url", "data"] }, Ne = "undefined" != typeof window && "undefined" != typeof document, Le = "object" == typeof navigator && navigator || void 0, je = Ne && (!Le || ["ReactNative", "NativeScript", "NS"].indexOf(Le.product) < 0), Ce = "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && "function" == typeof self.importScripts, De = Ne && window.location.href || "http://localhost", Ae = { ...d, ...Re }; const Fe = function (e) { function t(e, r, n, o) { let i = e[o++]; if ("__proto__" === i) return !0; const s = Number.isFinite(+i), a = o >= e.length; if (i = !i && le.isArray(n) ? n.length : i, a) return le.hasOwnProp(n, i) ? n[i] = [n[i], r] : n[i] = r, !s; n[i] && le.isObject(n[i]) || (n[i] = []); return t(e, r, n[i], o) && le.isArray(n[i]) && (n[i] = function (e) { const t = {}, r = Object.keys(e); let n; const o = r.length; let i; for (n = 0; n < o; n++)i = r[n], t[i] = e[i]; return t }(n[i])), !s } if (le.isFormData(e) && le.isFunction(e.entries)) { const r = {}; return le.forEachEntry(e, ((e, n) => { t(function (e) { return le.matchAll(/\w+|\[(\w*)]/g, e).map((e => "[]" === e[0] ? "" : e[1] || e[0])) }(e), n, r, 0) })), r } return null }; const _e = { transitional: Pe, adapter: ["xhr", "http", "fetch"], transformRequest: [function (e, t) { const r = t.getContentType() || "", n = r.indexOf("application/json") > -1, o = le.isObject(e); o && le.isHTMLForm(e) && (e = new FormData(e)); if (le.isFormData(e)) return n ? JSON.stringify(Fe(e)) : e; if (le.isArrayBuffer(e) || le.isBuffer(e) || le.isStream(e) || le.isFile(e) || le.isBlob(e) || le.isReadableStream(e)) return e; if (le.isArrayBufferView(e)) return e.buffer; if (le.isURLSearchParams(e)) return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString(); let i; if (o) { if (r.indexOf("application/x-www-form-urlencoded") > -1) return function (e, t) { return ve(e, new Ae.classes.URLSearchParams, Object.assign({ visitor: function (e, t, r, n) { return Ae.isNode && le.isBuffer(e) ? (this.append(t, e.toString("base64")), !1) : n.defaultVisitor.apply(this, arguments) } }, t)) }(e, this.formSerializer).toString(); if ((i = le.isFileList(e)) || r.indexOf("multipart/form-data") > -1) { const t = this.env && this.env.FormData; return ve(i ? { "files[]": e } : e, t && new t, this.formSerializer) } } return o || n ? (t.setContentType("application/json", !1), function (e, t, r) { if (le.isString(e)) try { return (t || JSON.parse)(e), le.trim(e) } catch (e) { if ("SyntaxError" !== e.name) throw e } return (r || JSON.stringify)(e) }(e)) : e }], transformResponse: [function (e) { const t = this.transitional || _e.transitional, r = t && t.forcedJSONParsing, n = "json" === this.responseType; if (le.isResponse(e) || le.isReadableStream(e)) return e; if (e && le.isString(e) && (r && !this.responseType || n)) { const r = !(t && t.silentJSONParsing) && n; try { return JSON.parse(e) } catch (e) { if (r) { if ("SyntaxError" === e.name) throw pe.from(e, pe.ERR_BAD_RESPONSE, this, null, this.response); throw e } } } return e }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: Ae.classes.FormData, Blob: Ae.classes.Blob }, validateStatus: function (e) { return e >= 200 && e < 300 }, headers: { common: { Accept: "application/json, text/plain, */*", "Content-Type": void 0 } } }; le.forEach(["delete", "get", "head", "post", "put", "patch"], (e => { _e.headers[e] = {} })); const xe = _e, Ie = le.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]), ke = Symbol("internals"); function Ue(e) { return e && String(e).trim().toLowerCase() } function qe(e) { return !1 === e || null == e ? e : le.isArray(e) ? e.map(qe) : String(e) } function Me(e, t, r, n, o) { return le.isFunction(n) ? n.call(this, t, r) : (o && (t = r), le.isString(t) ? le.isString(n) ? -1 !== t.indexOf(n) : le.isRegExp(n) ? n.test(t) : void 0 : void 0) } class $e { constructor(e) { e && this.set(e) } set(e, t, r) { const n = this; function o(e, t, r) { const o = Ue(t); if (!o) throw new Error("header name must be a non-empty string"); const i = le.findKey(n, o); (!i || void 0 === n[i] || !0 === r || void 0 === r && !1 !== n[i]) && (n[i || t] = qe(e)) } const i = (e, t) => le.forEach(e, ((e, r) => o(e, r, t))); if (le.isPlainObject(e) || e instanceof this.constructor) i(e, t); else if (le.isString(e) && (e = e.trim()) && !/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim())) i((e => { const t = {}; let r, n, o; return e && e.split("\n").forEach((function (e) { o = e.indexOf(":"), r = e.substring(0, o).trim().toLowerCase(), n = e.substring(o + 1).trim(), !r || t[r] && Ie[r] || ("set-cookie" === r ? t[r] ? t[r].push(n) : t[r] = [n] : t[r] = t[r] ? t[r] + ", " + n : n) })), t })(e), t); else if (le.isHeaders(e)) for (const [t, n] of e.entries()) o(n, t, r); else null != e && o(t, e, r); return this } get(e, t) { if (e = Ue(e)) { const r = le.findKey(this, e); if (r) { const e = this[r]; if (!t) return e; if (!0 === t) return function (e) { const t = Object.create(null), r = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g; let n; for (; n = r.exec(e);)t[n[1]] = n[2]; return t }(e); if (le.isFunction(t)) return t.call(this, e, r); if (le.isRegExp(t)) return t.exec(e); throw new TypeError("parser must be boolean|regexp|function") } } } has(e, t) { if (e = Ue(e)) { const r = le.findKey(this, e); return !(!r || void 0 === this[r] || t && !Me(0, this[r], r, t)) } return !1 } delete(e, t) { const r = this; let n = !1; function o(e) { if (e = Ue(e)) { const o = le.findKey(r, e); !o || t && !Me(0, r[o], o, t) || (delete r[o], n = !0) } } return le.isArray(e) ? e.forEach(o) : o(e), n } clear(e) { const t = Object.keys(this); let r = t.length, n = !1; for (; r--;) { const o = t[r]; e && !Me(0, this[o], o, e, !0) || (delete this[o], n = !0) } return n } normalize(e) { const t = this, r = {}; return le.forEach(this, ((n, o) => { const i = le.findKey(r, o); if (i) return t[i] = qe(n), void delete t[o]; const s = e ? function (e) { return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, ((e, t, r) => t.toUpperCase() + r)) }(o) : String(o).trim(); s !== o && delete t[o], t[s] = qe(n), r[s] = !0 })), this } concat(...e) { return this.constructor.concat(this, ...e) } toJSON(e) { const t = Object.create(null); return le.forEach(this, ((r, n) => { null != r && !1 !== r && (t[n] = e && le.isArray(r) ? r.join(", ") : r) })), t } [Symbol.iterator]() { return Object.entries(this.toJSON())[Symbol.iterator]() } toString() { return Object.entries(this.toJSON()).map((([e, t]) => e + ": " + t)).join("\n") } get [Symbol.toStringTag]() { return "AxiosHeaders" } static from(e) { return e instanceof this ? e : new this(e) } static concat(e, ...t) { const r = new this(e); return t.forEach((e => r.set(e))), r } static accessor(e) { const t = (this[ke] = this[ke] = { accessors: {} }).accessors, r = this.prototype; function n(e) { const n = Ue(e); t[n] || (!function (e, t) { const r = le.toCamelCase(" " + t);["get", "set", "has"].forEach((n => { Object.defineProperty(e, n + r, { value: function (e, r, o) { return this[n].call(this, t, e, r, o) }, configurable: !0 }) })) }(r, e), t[n] = !0) } return le.isArray(e) ? e.forEach(n) : n(e), this } } $e.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]), le.reduceDescriptors($e.prototype, (({ value: e }, t) => { let r = t[0].toUpperCase() + t.slice(1); return { get: () => e, set(e) { this[r] = e } } })), le.freezeMethods($e); const Be = $e; function Ge(e, t) { const r = this || xe, n = t || r, o = Be.from(n.headers); let i = n.data; return le.forEach(e, (function (e) { i = e.call(r, i, o.normalize(), t ? t.status : void 0) })), o.normalize(), i } function Ve(e) { return !(!e || !e.__CANCEL__) } function We(e, t, r) { pe.call(this, null == e ? "canceled" : e, pe.ERR_CANCELED, t, r), this.name = "CanceledError" } le.inherits(We, pe, { __CANCEL__: !0 }); const ze = We; function He(e, t, r) { const n = r.config.validateStatus; r.status && n && !n(r.status) ? t(new pe("Request failed with status code " + r.status, [pe.ERR_BAD_REQUEST, pe.ERR_BAD_RESPONSE][Math.floor(r.status / 100) - 4], r.config, r.request, r)) : e(r) } const Qe = function (e, t) { e = e || 10; const r = new Array(e), n = new Array(e); let o, i = 0, s = 0; return t = void 0 !== t ? t : 1e3, function (a) { const l = Date.now(), c = n[s]; o || (o = l), r[i] = a, n[i] = l; let u = s, d = 0; for (; u !== i;)d += r[u++], u %= e; if (i = (i + 1) % e, i === s && (s = (s + 1) % e), l - o < t) return; const p = c && l - c; return p ? Math.round(1e3 * d / p) : void 0 } }; const Je = function (e, t) { let r, n, o = 0, i = 1e3 / t; const s = (t, i = Date.now()) => { o = i, r = null, n && (clearTimeout(n), n = null), e.apply(null, t) }; return [(...e) => { const t = Date.now(), a = t - o; a >= i ? s(e, t) : (r = e, n || (n = setTimeout((() => { n = null, s(r) }), i - a))) }, () => r && s(r)] }, Ke = (e, t, r = 3) => { let n = 0; const o = Qe(50, 250); return Je((r => { const i = r.loaded, s = r.lengthComputable ? r.total : void 0, a = i - n, l = o(a); n = i; e({ loaded: i, total: s, progress: s ? i / s : void 0, bytes: a, rate: l || void 0, estimated: l && s && i <= s ? (s - i) / l : void 0, event: r, lengthComputable: null != s, [t ? "download" : "upload"]: !0 }) }), r) }, Xe = (e, t) => { const r = null != e; return [n => t[0]({ lengthComputable: r, total: e, loaded: n }), t[1]] }, Ze = e => (...t) => le.asap((() => e(...t))), Ye = Ae.hasStandardBrowserEnv ? ((e, t) => r => (r = new URL(r, Ae.origin), e.protocol === r.protocol && e.host === r.host && (t || e.port === r.port)))(new URL(Ae.origin), Ae.navigator && /(msie|trident)/i.test(Ae.navigator.userAgent)) : () => !0, et = Ae.hasStandardBrowserEnv ? { write(e, t, r, n, o, i) { const s = [e + "=" + encodeURIComponent(t)]; le.isNumber(r) && s.push("expires=" + new Date(r).toGMTString()), le.isString(n) && s.push("path=" + n), le.isString(o) && s.push("domain=" + o), !0 === i && s.push("secure"), document.cookie = s.join("; ") }, read(e) { const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)")); return t ? decodeURIComponent(t[3]) : null }, remove(e) { this.write(e, "", Date.now() - 864e5) } } : { write() { }, read: () => null, remove() { } }; function tt(e, t) { return e && !/^([a-z][a-z\d+\-.]*:)?\/\//i.test(t) ? function (e, t) { return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e }(e, t) : t } const rt = e => e instanceof Be ? { ...e } : e; function nt(e, t) { t = t || {}; const r = {}; function n(e, t, r, n) { return le.isPlainObject(e) && le.isPlainObject(t) ? le.merge.call({ caseless: n }, e, t) : le.isPlainObject(t) ? le.merge({}, t) : le.isArray(t) ? t.slice() : t } function o(e, t, r, o) { return le.isUndefined(t) ? le.isUndefined(e) ? void 0 : n(void 0, e, 0, o) : n(e, t, 0, o) } function i(e, t) { if (!le.isUndefined(t)) return n(void 0, t) } function s(e, t) { return le.isUndefined(t) ? le.isUndefined(e) ? void 0 : n(void 0, e) : n(void 0, t) } function a(r, o, i) { return i in t ? n(r, o) : i in e ? n(void 0, r) : void 0 } const l = { url: i, method: i, data: i, baseURL: s, transformRequest: s, transformResponse: s, paramsSerializer: s, timeout: s, timeoutMessage: s, withCredentials: s, withXSRFToken: s, adapter: s, responseType: s, xsrfCookieName: s, xsrfHeaderName: s, onUploadProgress: s, onDownloadProgress: s, decompress: s, maxContentLength: s, maxBodyLength: s, beforeRedirect: s, transport: s, httpAgent: s, httpsAgent: s, cancelToken: s, socketPath: s, responseEncoding: s, validateStatus: a, headers: (e, t, r) => o(rt(e), rt(t), 0, !0) }; return le.forEach(Object.keys(Object.assign({}, e, t)), (function (n) { const i = l[n] || o, s = i(e[n], t[n], n); le.isUndefined(s) && i !== a || (r[n] = s) })), r } const ot = e => { const t = nt({}, e); let r, { data: n, withXSRFToken: o, xsrfHeaderName: i, xsrfCookieName: s, headers: a, auth: l } = t; if (t.headers = a = Be.from(a), t.url = Te(tt(t.baseURL, t.url), e.params, e.paramsSerializer), l && a.set("Authorization", "Basic " + btoa((l.username || "") + ":" + (l.password ? unescape(encodeURIComponent(l.password)) : ""))), le.isFormData(n)) if (Ae.hasStandardBrowserEnv || Ae.hasStandardBrowserWebWorkerEnv) a.setContentType(void 0); else if (!1 !== (r = a.getContentType())) { const [e, ...t] = r ? r.split(";").map((e => e.trim())).filter(Boolean) : []; a.setContentType([e || "multipart/form-data", ...t].join("; ")) } if (Ae.hasStandardBrowserEnv && (o && le.isFunction(o) && (o = o(t)), o || !1 !== o && Ye(t.url))) { const e = i && s && et.read(s); e && a.set(i, e) } return t }, it = "undefined" != typeof XMLHttpRequest && function (e) { return new Promise((function (t, r) { const n = ot(e); let o = n.data; const i = Be.from(n.headers).normalize(); let s, a, l, c, u, { responseType: d, onUploadProgress: p, onDownloadProgress: m } = n; function h() { c && c(), u && u(), n.cancelToken && n.cancelToken.unsubscribe(s), n.signal && n.signal.removeEventListener("abort", s) } let f = new XMLHttpRequest; function g() { if (!f) return; const n = Be.from("getAllResponseHeaders" in f && f.getAllResponseHeaders()); He((function (e) { t(e), h() }), (function (e) { r(e), h() }), { data: d && "text" !== d && "json" !== d ? f.response : f.responseText, status: f.status, statusText: f.statusText, headers: n, config: e, request: f }), f = null } f.open(n.method.toUpperCase(), n.url, !0), f.timeout = n.timeout, "onloadend" in f ? f.onloadend = g : f.onreadystatechange = function () { f && 4 === f.readyState && (0 !== f.status || f.responseURL && 0 === f.responseURL.indexOf("file:")) && setTimeout(g) }, f.onabort = function () { f && (r(new pe("Request aborted", pe.ECONNABORTED, e, f)), f = null) }, f.onerror = function () { r(new pe("Network Error", pe.ERR_NETWORK, e, f)), f = null }, f.ontimeout = function () { let t = n.timeout ? "timeout of " + n.timeout + "ms exceeded" : "timeout exceeded"; const o = n.transitional || Pe; n.timeoutErrorMessage && (t = n.timeoutErrorMessage), r(new pe(t, o.clarifyTimeoutError ? pe.ETIMEDOUT : pe.ECONNABORTED, e, f)), f = null }, void 0 === o && i.setContentType(null), "setRequestHeader" in f && le.forEach(i.toJSON(), (function (e, t) { f.setRequestHeader(t, e) })), le.isUndefined(n.withCredentials) || (f.withCredentials = !!n.withCredentials), d && "json" !== d && (f.responseType = n.responseType), m && ([l, u] = Ke(m, !0), f.addEventListener("progress", l)), p && f.upload && ([a, c] = Ke(p), f.upload.addEventListener("progress", a), f.upload.addEventListener("loadend", c)), (n.cancelToken || n.signal) && (s = t => { f && (r(!t || t.type ? new ze(null, e, f) : t), f.abort(), f = null) }, n.cancelToken && n.cancelToken.subscribe(s), n.signal && (n.signal.aborted ? s() : n.signal.addEventListener("abort", s))); const v = function (e) { const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e); return t && t[1] || "" }(n.url); v && -1 === Ae.protocols.indexOf(v) ? r(new pe("Unsupported protocol " + v + ":", pe.ERR_BAD_REQUEST, e)) : f.send(o || null) })) }, st = (e, t) => { const { length: r } = e = e ? e.filter(Boolean) : []; if (t || r) { let r, n = new AbortController; const o = function (e) { if (!r) { r = !0, s(); const t = e instanceof Error ? e : this.reason; n.abort(t instanceof pe ? t : new ze(t instanceof Error ? t.message : t)) } }; let i = t && setTimeout((() => { i = null, o(new pe(`timeout ${t} of ms exceeded`, pe.ETIMEDOUT)) }), t); const s = () => { e && (i && clearTimeout(i), i = null, e.forEach((e => { e.unsubscribe ? e.unsubscribe(o) : e.removeEventListener("abort", o) })), e = null) }; e.forEach((e => e.addEventListener("abort", o))); const { signal: a } = n; return a.unsubscribe = () => le.asap(s), a } }, at = function* (e, t) { let r = e.byteLength; if (!t || r < t) return void (yield e); let n, o = 0; for (; o < r;)n = o + t, yield e.slice(o, n), o = n }, lt = async function* (e) { if (e[Symbol.asyncIterator]) return void (yield* e); const t = e.getReader(); try { for (; ;) { const { done: e, value: r } = await t.read(); if (e) break; yield r } } finally { await t.cancel() } }, ct = (e, t, r, n) => { const o = async function* (e, t) { for await (const r of lt(e)) yield* at(r, t) }(e, t); let i, s = 0, a = e => { i || (i = !0, n && n(e)) }; return new ReadableStream({ async pull(e) { try { const { done: t, value: n } = await o.next(); if (t) return a(), void e.close(); let i = n.byteLength; if (r) { let e = s += i; r(e) } e.enqueue(new Uint8Array(n)) } catch (e) { throw a(e), e } }, cancel: e => (a(e), o.return()) }, { highWaterMark: 2 }) }, ut = "function" == typeof fetch && "function" == typeof Request && "function" == typeof Response, dt = ut && "function" == typeof ReadableStream, pt = ut && ("function" == typeof TextEncoder ? (mt = new TextEncoder, e => mt.encode(e)) : async e => new Uint8Array(await new Response(e).arrayBuffer())); var mt; const ht = (e, ...t) => { try { return !!e(...t) } catch (e) { return !1 } }, ft = dt && ht((() => { let e = !1; const t = new Request(Ae.origin, { body: new ReadableStream, method: "POST", get duplex() { return e = !0, "half" } }).headers.has("Content-Type"); return e && !t })), gt = dt && ht((() => le.isReadableStream(new Response("").body))), vt = { stream: gt && (e => e.body) }; var yt; ut && (yt = new Response, ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((e => { !vt[e] && (vt[e] = le.isFunction(yt[e]) ? t => t[e]() : (t, r) => { throw new pe(`Response type '${e}' is not supported`, pe.ERR_NOT_SUPPORT, r) }) }))); const bt = async (e, t) => { const r = le.toFiniteNumber(e.getContentLength()); return null == r ? (async e => { if (null == e) return 0; if (le.isBlob(e)) return e.size; if (le.isSpecCompliantForm(e)) { const t = new Request(Ae.origin, { method: "POST", body: e }); return (await t.arrayBuffer()).byteLength } return le.isArrayBufferView(e) || le.isArrayBuffer(e) ? e.byteLength : (le.isURLSearchParams(e) && (e += ""), le.isString(e) ? (await pt(e)).byteLength : void 0) })(t) : r }, St = { http: null, xhr: it, fetch: ut && (async e => { let { url: t, method: r, data: n, signal: o, cancelToken: i, timeout: s, onDownloadProgress: a, onUploadProgress: l, responseType: c, headers: u, withCredentials: d = "same-origin", fetchOptions: p } = ot(e); c = c ? (c + "").toLowerCase() : "text"; let m, h = st([o, i && i.toAbortSignal()], s); const f = h && h.unsubscribe && (() => { h.unsubscribe() }); let g; try { if (l && ft && "get" !== r && "head" !== r && 0 !== (g = await bt(u, n))) { let e, r = new Request(t, { method: "POST", body: n, duplex: "half" }); if (le.isFormData(n) && (e = r.headers.get("content-type")) && u.setContentType(e), r.body) { const [e, t] = Xe(g, Ke(Ze(l))); n = ct(r.body, 65536, e, t) } } le.isString(d) || (d = d ? "include" : "omit"); const o = "credentials" in Request.prototype; m = new Request(t, { ...p, signal: h, method: r.toUpperCase(), headers: u.normalize().toJSON(), body: n, duplex: "half", credentials: o ? d : void 0 }); let i = await fetch(m); const s = gt && ("stream" === c || "response" === c); if (gt && (a || s && f)) { const e = {};["status", "statusText", "headers"].forEach((t => { e[t] = i[t] })); const t = le.toFiniteNumber(i.headers.get("content-length")), [r, n] = a && Xe(t, Ke(Ze(a), !0)) || []; i = new Response(ct(i.body, 65536, r, (() => { n && n(), f && f() })), e) } c = c || "text"; let v = await vt[le.findKey(vt, c) || "text"](i, e); return !s && f && f(), await new Promise(((t, r) => { He(t, r, { data: v, headers: Be.from(i.headers), status: i.status, statusText: i.statusText, config: e, request: m }) })) } catch (t) { if (f && f(), t && "TypeError" === t.name && /fetch/i.test(t.message)) throw Object.assign(new pe("Network Error", pe.ERR_NETWORK, e, m), { cause: t.cause || t }); throw pe.from(t, t && t.code, e, m) } }) }; le.forEach(St, ((e, t) => { if (e) { try { Object.defineProperty(e, "name", { value: t }) } catch (e) { } Object.defineProperty(e, "adapterName", { value: t }) } })); const wt = e => `- ${e}`, Et = e => le.isFunction(e) || null === e || !1 === e, Tt = e => { e = le.isArray(e) ? e : [e]; const { length: t } = e; let r, n; const o = {}; for (let i = 0; i < t; i++) { let t; if (r = e[i], n = r, !Et(r) && (n = St[(t = String(r)).toLowerCase()], void 0 === n)) throw new pe(`Unknown adapter '${t}'`); if (n) break; o[t || "#" + i] = n } if (!n) { const e = Object.entries(o).map((([e, t]) => `adapter ${e} ` + (!1 === t ? "is not supported by the environment" : "is not available in the build"))); let r = t ? e.length > 1 ? "since :\n" + e.map(wt).join("\n") : " " + wt(e[0]) : "as no adapter specified"; throw new pe("There is no suitable adapter to dispatch the request " + r, "ERR_NOT_SUPPORT") } return n }; function Ot(e) { if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted) throw new ze(null, e) } function Pt(e) { Ot(e), e.headers = Be.from(e.headers), e.data = Ge.call(e, e.transformRequest), -1 !== ["post", "put", "patch"].indexOf(e.method) && e.headers.setContentType("application/x-www-form-urlencoded", !1); return Tt(e.adapter || xe.adapter)(e).then((function (t) { return Ot(e), t.data = Ge.call(e, e.transformResponse, t), t.headers = Be.from(t.headers), t }), (function (t) { return Ve(t) || (Ot(e), t && t.response && (t.response.data = Ge.call(e, e.transformResponse, t.response), t.response.headers = Be.from(t.response.headers))), Promise.reject(t) })) } const Rt = "1.7.9", Nt = {};["object", "boolean", "number", "function", "string", "symbol"].forEach(((e, t) => { Nt[e] = function (r) { return typeof r === e || "a" + (t < 1 ? "n " : " ") + e } })); const Lt = {}; Nt.transitional = function (e, t, r) { function n(e, t) { return "[Axios v1.7.9] Transitional option '" + e + "'" + t + (r ? ". " + r : "") } return (r, o, i) => { if (!1 === e) throw new pe(n(o, " has been removed" + (t ? " in " + t : "")), pe.ERR_DEPRECATED); return t && !Lt[o] && (Lt[o] = !0, console.warn(n(o, " has been deprecated since v" + t + " and will be removed in the near future"))), !e || e(r, o, i) } }, Nt.spelling = function (e) { return (t, r) => (console.warn(`${r} is likely a misspelling of ${e}`), !0) }; const jt = { assertOptions: function (e, t, r) { if ("object" != typeof e) throw new pe("options must be an object", pe.ERR_BAD_OPTION_VALUE); const n = Object.keys(e); let o = n.length; for (; o-- > 0;) { const i = n[o], s = t[i]; if (s) { const t = e[i], r = void 0 === t || s(t, i, e); if (!0 !== r) throw new pe("option " + i + " must be " + r, pe.ERR_BAD_OPTION_VALUE) } else if (!0 !== r) throw new pe("Unknown option " + i, pe.ERR_BAD_OPTION) } }, validators: Nt }, Ct = jt.validators; class Dt { constructor(e) { this.defaults = e, this.interceptors = { request: new Oe, response: new Oe } } async request(e, t) { try { return await this._request(e, t) } catch (e) { if (e instanceof Error) { let t = {}; Error.captureStackTrace ? Error.captureStackTrace(t) : t = new Error; const r = t.stack ? t.stack.replace(/^.+\n/, "") : ""; try { e.stack ? r && !String(e.stack).endsWith(r.replace(/^.+\n.+\n/, "")) && (e.stack += "\n" + r) : e.stack = r } catch (e) { } } throw e } } _request(e, t) { "string" == typeof e ? (t = t || {}).url = e : t = e || {}, t = nt(this.defaults, t); const { transitional: r, paramsSerializer: n, headers: o } = t; void 0 !== r && jt.assertOptions(r, { silentJSONParsing: Ct.transitional(Ct.boolean), forcedJSONParsing: Ct.transitional(Ct.boolean), clarifyTimeoutError: Ct.transitional(Ct.boolean) }, !1), null != n && (le.isFunction(n) ? t.paramsSerializer = { serialize: n } : jt.assertOptions(n, { encode: Ct.function, serialize: Ct.function }, !0)), jt.assertOptions(t, { baseUrl: Ct.spelling("baseURL"), withXsrfToken: Ct.spelling("withXSRFToken") }, !0), t.method = (t.method || this.defaults.method || "get").toLowerCase(); let i = o && le.merge(o.common, o[t.method]); o && le.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (e => { delete o[e] })), t.headers = Be.concat(i, o); const s = []; let a = !0; this.interceptors.request.forEach((function (e) { "function" == typeof e.runWhen && !1 === e.runWhen(t) || (a = a && e.synchronous, s.unshift(e.fulfilled, e.rejected)) })); const l = []; let c; this.interceptors.response.forEach((function (e) { l.push(e.fulfilled, e.rejected) })); let u, d = 0; if (!a) { const e = [Pt.bind(this), void 0]; for (e.unshift.apply(e, s), e.push.apply(e, l), u = e.length, c = Promise.resolve(t); d < u;)c = c.then(e[d++], e[d++]); return c } u = s.length; let p = t; for (d = 0; d < u;) { const e = s[d++], t = s[d++]; try { p = e(p) } catch (e) { t.call(this, e); break } } try { c = Pt.call(this, p) } catch (e) { return Promise.reject(e) } for (d = 0, u = l.length; d < u;)c = c.then(l[d++], l[d++]); return c } getUri(e) { return Te(tt((e = nt(this.defaults, e)).baseURL, e.url), e.params, e.paramsSerializer) } } le.forEach(["delete", "get", "head", "options"], (function (e) { Dt.prototype[e] = function (t, r) { return this.request(nt(r || {}, { method: e, url: t, data: (r || {}).data })) } })), le.forEach(["post", "put", "patch"], (function (e) { function t(t) { return function (r, n, o) { return this.request(nt(o || {}, { method: e, headers: t ? { "Content-Type": "multipart/form-data" } : {}, url: r, data: n })) } } Dt.prototype[e] = t(), Dt.prototype[e + "Form"] = t(!0) })); const At = Dt; class Ft { constructor(e) { if ("function" != typeof e) throw new TypeError("executor must be a function."); let t; this.promise = new Promise((function (e) { t = e })); const r = this; this.promise.then((e => { if (!r._listeners) return; let t = r._listeners.length; for (; t-- > 0;)r._listeners[t](e); r._listeners = null })), this.promise.then = e => { let t; const n = new Promise((e => { r.subscribe(e), t = e })).then(e); return n.cancel = function () { r.unsubscribe(t) }, n }, e((function (e, n, o) { r.reason || (r.reason = new ze(e, n, o), t(r.reason)) })) } throwIfRequested() { if (this.reason) throw this.reason } subscribe(e) { this.reason ? e(this.reason) : this._listeners ? this._listeners.push(e) : this._listeners = [e] } unsubscribe(e) { if (!this._listeners) return; const t = this._listeners.indexOf(e); -1 !== t && this._listeners.splice(t, 1) } toAbortSignal() { const e = new AbortController, t = t => { e.abort(t) }; return this.subscribe(t), e.signal.unsubscribe = () => this.unsubscribe(t), e.signal } static source() { let e; return { token: new Ft((function (t) { e = t })), cancel: e } } } const _t = Ft; const xt = { Continue: 100, SwitchingProtocols: 101, Processing: 102, EarlyHints: 103, Ok: 200, Created: 201, Accepted: 202, NonAuthoritativeInformation: 203, NoContent: 204, ResetContent: 205, PartialContent: 206, MultiStatus: 207, AlreadyReported: 208, ImUsed: 226, MultipleChoices: 300, MovedPermanently: 301, Found: 302, SeeOther: 303, NotModified: 304, UseProxy: 305, Unused: 306, TemporaryRedirect: 307, PermanentRedirect: 308, BadRequest: 400, Unauthorized: 401, PaymentRequired: 402, Forbidden: 403, NotFound: 404, MethodNotAllowed: 405, NotAcceptable: 406, ProxyAuthenticationRequired: 407, RequestTimeout: 408, Conflict: 409, Gone: 410, LengthRequired: 411, PreconditionFailed: 412, PayloadTooLarge: 413, UriTooLong: 414, UnsupportedMediaType: 415, RangeNotSatisfiable: 416, ExpectationFailed: 417, ImATeapot: 418, MisdirectedRequest: 421, UnprocessableEntity: 422, Locked: 423, FailedDependency: 424, TooEarly: 425, UpgradeRequired: 426, PreconditionRequired: 428, TooManyRequests: 429, RequestHeaderFieldsTooLarge: 431, UnavailableForLegalReasons: 451, InternalServerError: 500, NotImplemented: 501, BadGateway: 502, ServiceUnavailable: 503, GatewayTimeout: 504, HttpVersionNotSupported: 505, VariantAlsoNegotiates: 506, InsufficientStorage: 507, LoopDetected: 508, NotExtended: 510, NetworkAuthenticationRequired: 511 }; Object.entries(xt).forEach((([e, t]) => { xt[t] = e })); const It = xt; const kt = function e(t) { const r = new At(t), n = y(At.prototype.request, r); return le.extend(n, At.prototype, r, { allOwnKeys: !0 }), le.extend(n, r, null, { allOwnKeys: !0 }), n.create = function (r) { return e(nt(t, r)) }, n }(xe); kt.Axios = At, kt.CanceledError = ze, kt.CancelToken = _t, kt.isCancel = Ve, kt.VERSION = Rt, kt.toFormData = ve, kt.AxiosError = pe, kt.Cancel = kt.CanceledError, kt.all = function (e) { return Promise.all(e) }, kt.spread = function (e) { return function (t) { return e.apply(null, t) } }, kt.isAxiosError = function (e) { return le.isObject(e) && !0 === e.isAxiosError }, kt.mergeConfig = nt, kt.AxiosHeaders = Be, kt.formToJSON = e => Fe(le.isHTMLForm(e) ? new FormData(e) : e), kt.getAdapter = Tt, kt.HttpStatusCode = It, kt.default = kt; const Ut = kt; function qt(e, t, r, n, o, i, s) { try { var a = e[i](s), l = a.value } catch (e) { return void r(e) } a.done ? t(l) : Promise.resolve(l).then(n, o) } function Mt(e) { return function () { var t = this, r = arguments; return new Promise((function (n, o) { var i = e.apply(t, r); function s(e) { qt(i, n, o, s, a, "next", e) } function a(e) { qt(i, n, o, s, a, "throw", e) } s(void 0) })) } } function $t(e, t, r) { return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e } class Bt { has(e) { return this.isCacheValid(e) } get(e) { return this.getCachedData(e) } set(e, t) { this.setCacheData(e, t) } isCacheValid(e) { const t = this.cache.get(e); if (!t) return !1; return !(Date.now() - t.timestamp > 1e3 * this.defaultTimeout) || (this.cache.delete(e), !1) } getCachedData(e) { const t = this.cache.get(e); return t && !this.isExpired(t) ? t.data : null } setCacheData(e, t) { e && this.cache.set(e, { data: t, timestamp: Date.now(), timeout: this.defaultTimeout }) } clear() { this.cache.clear() } isExpired(e) { return Date.now() - e.timestamp > 1e3 * e.timeout } isInCache(e) { const t = this.cache.get(e); if (!t) return !1; return !(Date.now() - t.timestamp > 1e3 * t.timeout) || (this.cache.delete(e), !1) } getCache(e) { var t = this; return Mt((function* () { return Promise.resolve(t.getCachedData(t.hashValue(e))) }))() } setCache(e, t) { var r = this; return Mt((function* () { const n = r.hashValue(e); return r.setCacheData(n, t), r.getCache(e) }))() } hashValue(e) { let t = 0; if (0 === e.length) return t.toString(); for (let r = 0; r < e.length; r++) { t = (t << 5) - t + e.charCodeAt(r), t |= 0 } return t.toString() } constructor(e = 300) { $t(this, "cache", void 0), $t(this, "defaultTimeout", void 0), this.cache = new Map, this.defaultTimeout = e } } function Gt(e, t, r) { return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e } class Vt extends Error { static fromAxiosError(e) { var t, r, n; const o = (null === (t = e.response) || void 0 === t ? void 0 : t.status) || "unknown", i = (null === (r = e.response) || void 0 === r ? void 0 : r.statusText) || "Unknown error"; return new Vt(`PRTG API Error (${o}): ${i}`, String(o), null === (n = e.response) || void 0 === n ? void 0 : n.data) } constructor(e, t, r) { super(e), Gt(this, "message", void 0), Gt(this, "code", void 0), Gt(this, "details", void 0), this.message = e, this.code = t, this.details = r, this.name = "PRTGError", Object.setPrototypeOf(this, Vt.prototype) } } var Wt = c(269); function zt(e, t, r, n, o, i, s) { try { var a = e[i](s), l = a.value } catch (e) { return void r(e) } a.done ? t(l) : Promise.resolve(l).then(n, o) } function Ht(e) { return function () { var t = this, r = arguments; return new Promise((function (n, o) { var i = e.apply(t, r); function s(e) { zt(i, n, o, s, a, "next", e) } function a(e) { zt(i, n, o, s, a, "throw", e) } s(void 0) })) } } function Qt(e, t, r) { return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e } class Jt { get baseUrl() { return this.config.baseUrl } get username() { return this.config.username } get passwordHash() { return this.config.passwordHash } get cacheTimeout() { return this.config.cacheTimeout || 300 } get enableTimeZoneAdjust() { return this.config.enableTimeZoneAdjust || !1 } executeRequest(e, t) { var r = this; return Ht((function* () { const n = r.baseUrl + e, o = `username=${r.username}&passhash=${r.passwordHash}`, i = `${n}?${t ? `${o}&${t}` : o}`; try { const t = yield Ut.get(i, { headers: { "Content-Type": "application/json", Accept: "application/json" } }); if (!t.data) throw new Vt("Response contained no data"); return e.includes("table.json") && t.data["prtg-version"] ? t.data : r.processResponse(t.data) } catch (e) { var s; if (Ut.isAxiosError(e) && 403 === (null === (s = e.response) || void 0 === s ? void 0 : s.status)) throw new Vt("Access denied. Please verify authentication and permissions."); throw r.handleRequestError(e) } }))() } processResponse(e) { if (e && e.Version) return e; if (e["prtg-version"]) return e.groups ? e.groups : e; const t = { groups: !0, devices: !0, sensors: !0, channels: !0, values: !0, sensordata: !0, messages: !0 }; for (const r in t) if (e[r]) return e[r]; if ("Not enough monitoring data" === e) throw new Error("Not enough monitoring data."); return e } handleRequestError(e) { if (console.error("PRTG API Request failed:", e), Ut.isAxiosError(e)) throw Vt.fromAxiosError(e); throw new Vt(e.message || "Unknown error") } initializeTimeZoneOffset() { var e = this; return Ht((function* () { if (e.enableTimeZoneAdjust) try { const t = (yield e.executeRequest("table.json?")).jsClock, r = Date.now() / 1e3; e.tzAutoAdjustValue = 1e3 * Math.round(r - t) } catch (e) { } }))() } getVersion() { var e = this; return Ht((function* () { try { return (0, Wt.lastValueFrom)((0, Wt.from)(e.executeRequest("status.json")).pipe((0, Wt.map)((e => e && "object" == typeof e && "Version" in e ? e.Version : e && "object" == typeof e && "prtg-version" in e ? e["prtg-version"] : "Unknown Version")), (0, Wt.catchError)((e => { throw console.error("Failed to get version:", e), new Error(`Version query failed: ${e instanceof Error ? e.message : "Unknown error"}`) })))) } catch (e) { return console.error("Failed to get version:", e), `ERROR: ${e instanceof Error ? e.message : "Unknown error"}` } }))() } sortItems(e, t) { return v().orderBy(e, [t], ["asc"]) } performGroupSuggestQuery() { var e = this; return Ht((function* () { try { const t = new URLSearchParams({ content: "groups", count: "50000", columns: e.columns }); return (0, Wt.lastValueFrom)((0, Wt.from)(e.executeRequest("table.json", t)).pipe((0, Wt.map)((t => { if (!(null == t ? void 0 : t.groups)) throw new Error("No group data received from PRTG"); return e.sortItems(t.groups, "group") })), (0, Wt.catchError)((e => { throw console.error("Failed to perform group suggest query:", e), new Error(`Group query failed: ${e instanceof Error ? e.message : "Unknown error"}`) })))) } catch (e) { throw console.error("Failed to perform group suggest query:", e), new Error(`Group query failed: ${e instanceof Error ? e.message : "Unknown error"}`) } }))() } performDeviceSuggestQuery(e) { var t = this; return Ht((function* () { try { const r = new URLSearchParams({ content: "devices", count: "50000", columns: t.columns }); if (e) { const t = e.startsWith("filter_group=") ? decodeURIComponent(e.split("=")[1]) : e; r.append("filter_group", t) } return (0, Wt.lastValueFrom)((0, Wt.from)(t.executeRequest("table.json", r)).pipe((0, Wt.map)((e => { if (!(null == e ? void 0 : e.devices)) throw new Error("No device data received from PRTG"); return t.sortItems(e.devices, "device") })), (0, Wt.catchError)((e => { throw console.error("Failed to perform device suggest query:", e), new Error(`Device query failed: ${e instanceof Error ? e.message : "Unknown error"}`) })))) } catch (e) { throw console.error("Failed to query devices:", e), new Error(`Device query failed: ${e instanceof Error ? e.message : "Unknown error"}`) } }))() } performSensorSuggestQuery(e) { var t = this; return Ht((function* () { try { const r = new URLSearchParams({ content: "sensors", count: "50000", columns: t.columns }); if (e) { const t = e.startsWith("filter_device=") ? decodeURIComponent(e.split("=")[1]) : e; r.append("filter_device", t) } return (0, Wt.lastValueFrom)((0, Wt.from)(t.executeRequest("table.json", r)).pipe((0, Wt.map)((e => { if (!(null == e ? void 0 : e.sensors)) throw new Error("No sensor data received from PRTG"); return t.sortItems(e.sensors, "sensor") })), (0, Wt.catchError)((e => { throw console.error("Failed to perform sensor suggest query:", e), new Error(`Sensor query failed: ${e instanceof Error ? e.message : "Unknown error"}`) })))) } catch (e) { throw console.error("Failed to query sensors:", e), new Error(`Sensor query failed: ${e instanceof Error ? e.message : "Unknown error"}`) } }))() } performChannelSuggestQuery(e, t, r) { var n = this; return Ht((function* () { try { const o = new URLSearchParams({ content: "sensors", count: "50000", columns: n.columns }); if (e) { const t = e.startsWith("filter_group=") ? decodeURIComponent(e.split("=")[1]) : e; o.append("filter_group", t) } if (t) { const e = t.startsWith("filter_device=") ? decodeURIComponent(t.split("=")[1]) : t; o.append("filter_device", e) } if (r) { const e = r.startsWith("filter_sensor=") ? decodeURIComponent(r.split("=")[1]) : r; o.append("filter_sensor", e) } return (0, Wt.lastValueFrom)((0, Wt.from)(n.executeRequest("table.json", o)).pipe((0, Wt.map)((e => { if (!(null == e ? void 0 : e.sensors)) throw new Error("No sensor data received from PRTG"); return n.sortItems(e.sensors, "sensor") })), (0, Wt.catchError)((e => { throw console.error("Failed to perform channel suggest query:", e), new Error(`Channel query failed: ${e instanceof Error ? e.message : "Unknown error"}`) })))) } catch (e) { throw console.error("Failed to query channels:", e), new Error(`Channel query failed: ${e instanceof Error ? e.message : "Unknown error"}`) } }))() } performValueSuggestQuery(e, t, r, n) { var o = this; return Ht((function* () { try { if (n.length > 0) { var i, s; const n = yield o.performChannelSuggestQuery(e, t, r); if (!(null == n || null === (i = n[0]) || void 0 === i ? void 0 : i.objid)) return []; o.sensorId = n[0].objid; const a = new URLSearchParams({ content: "values", columns: "value_,datetime", usecaption: "true", output: "json", count: "1", id: o.sensorId.toString() }), l = yield o.executeRequest("table.json", a); return (null == l || null === (s = l.values) || void 0 === s ? void 0 : s[0]) ? l.values : [] } return [] } catch (e) { return [] } }))() } performQuerySuggestQuery(e, t, r) { var n = this; return Ht((function* () { if (!r || 0 === r.length || !r[0].sensorId) throw new Error("Invalid query: Missing sensor ID"); const o = new Date(e).getTime() / 1e3, i = (new Date(t).getTime() / 1e3 - o) / 3600, s = v().cond([[e => e > 12 && e < 36, () => "300"], [e => e > 36 && e < 745, () => "3600"], [e => e > 745, () => "86400"], [v().stubTrue, () => "0"]])(i), a = v().memoize((e => { const t = new Date(e); return `${t.getFullYear()}-${v().padStart(String(t.getMonth() + 1), 2, "0")}-${v().padStart(String(t.getDate()), 2, "0")}-${v().padStart(String(t.getHours()), 2, "0")}-${v().padStart(String(t.getMinutes()), 2, "0")}-${v().padStart(String(t.getSeconds()), 2, "0")}` })); try { const o = Number(r[0].sensorId); if (isNaN(o)) throw new Error("Invalid sensor ID"); const i = new URLSearchParams; i.append("id", o.toString()), i.append("avg", s), i.append("sdate", a(e)), i.append("edate", a(t)), i.append("count", "50000"), i.append("usecaption", "1"), i.append("columns", "datetime,value_"), r[0].channelId && "*" !== r[0].channelId && i.append("channel", r[0].channelId); const l = yield n.executeRequest("historicdata.json", i); if (!l.histdata || 0 === l.histdata.length) throw new Error("No historical data received from PRTG"); return l } catch (e) { throw console.error("Failed to perform historical data query:", e), new Error(`Historical data query failed: ${e instanceof Error ? e.message : "Unknown error"}`) } }))() } getMessages(e, t, r) { var n = this; return Ht((function* () { const o = new URLSearchParams({ content: "messages", columns: "objid,datetime,parent,type,name,status,message,tags", id: r.toString() }).toString(); return (0, Wt.lastValueFrom)((0, Wt.from)(n.executeRequest("table.json", o)).pipe((0, Wt.map)((r => Array.isArray(r) ? v()(r).map((r => { const o = Math.round(86400 * (r.datetime_raw - 25569)), i = Number(e), s = Number(t); return isNaN(o) || isNaN(i) || isNaN(s) || !r.parent || !r.type || !r.message || o <= i || o >= s ? null : { time: 1e3 * o, title: r.status, text: n.formatMessageText({ parent: r.parent, type: r.type, message: r.message }), tags: r.tags ? v().map(r.tags.split(","), (e => e.trim())) : [] } })).compact().value() : [])), (0, Wt.catchError)((e => { throw console.error("Failed to get messages:", e), new Error(`Message retrieval failed: ${e instanceof Error ? e.message : "Unknown error"}`) })))) }))() } formatMessageText(e) { return e.parent && e.type && e.message ? `<p>${e.parent} (${e.type}) Message:<br>${e.message}</p>` : "<p>No message details available</p>" } testAuth() { var e = this; return Ht((function* () { try { return (0, Wt.lastValueFrom)((0, Wt.from)(e.executeRequest("table.json")).pipe((0, Wt.map)((e => { if (!e) throw new Error("No response received from PRTG"); return !0 })), (0, Wt.catchError)((e => (console.error("Failed to test authentication:", e), (0, Wt.from)([!1])))))) } catch (e) { return console.error("Authentication test failed:", e), !1 } }))() } getGroupInfo(e) { var t = this; return Ht((function* () { try { const r = (yield t.performGroupSuggestQuery()).find((t => t.group === e)); if (!r) throw new Error(`Group not found: ${e}`); return r } catch (e) { throw console.error("Failed to get group info:", e), new Error(`Group info retrieval failed: ${e instanceof Error ? e.message : "Unknown error"}`) } }))() } getDeviceInfo(e) { var t = this; return Ht((function* () { try { const r = (yield t.performDeviceSuggestQuery()).find((t => t.device === e)); if (!r) throw new Error(`Device not found: ${e}`); return r } catch (e) { throw console.error("Failed to get device info:", e), new Error(`Device info retrieval failed: ${e instanceof Error ? e.message : "Unknown error"}`) } }))() } getSensorInfo(e) { var t = this; return Ht((function* () { try { const r = (yield t.performSensorSuggestQuery()).find((t => t.sensor === e)); if (!r) throw new Error(`Sensor not found: ${e}`); return r } catch (e) { throw console.error("Failed to get sensor info:", e), new Error(`Sensor info retrieval failed: ${e instanceof Error ? e.message : "Unknown error"}`) } }))() } constructor(e) { Qt(this, "config", void 0), Qt(this, "cacheService", void 0), Qt(this, "tzAutoAdjustValue", 0), Qt(this, "sensorId", void 0), Qt(this, "columns", ["objid", "group", "device", "sensor", "channel", "active", "message", "priority", "status", "status_raw", "tags", "datetime"].join(",")), this.config = e, this.cacheService = new Bt(e.cacheTimeout || 300), this.sensorId = 0, e.enableTimeZoneAdjust && this.initializeTimeZoneOffset() } } function Kt(e, t, r, n, o, i, s) { try { var a = e[i](s), l = a.value } catch (e) { return void r(e) } a.done ? t(l) : Promise.resolve(l).then(n, o) } function Xt(e) { return function () { var t = this, r = arguments; return new Promise((function (n, o) { var i = e.apply(t, r); function s(e) { Kt(i, n, o, s, a, "next", e) } function a(e) { Kt(i, n, o, s, a, "throw", e) } s(void 0) })) } } function Zt(e, t, r) { return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e } function Yt(e) { for (var t = 1; t < arguments.length; t++) { var r = null != arguments[t] ? arguments[t] : {}, n = Object.keys(r); "function" == typeof Object.getOwnPropertySymbols && (n = n.concat(Object.getOwnPropertySymbols(r).filter((function (e) { return Object.getOwnPropertyDescriptor(r, e).enumerable })))), n.forEach((function (t) { Zt(e, t, r[t]) })) } return e } function er(e, t) { return t = null != t ? t : {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : function (e, t) { var r = Object.keys(e); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); t && (n = n.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), r.push.apply(r, n) } return r }(Object(t)).forEach((function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)) })), e } class tr extends h.DataSourceApi { parseTimeout(e, t) { if ("string" == typeof e) { const r = parseInt(e, 10); return isNaN(r) ? t : r } return "number" == typeof e ? e : t } parsePRTGDateTime(e) { const [t, r] = e.split(" "), [n, o, i] = t.split("."), [s, a, l] = (r || "00:00:00").split(":"); return new Date(parseInt(i, 10), parseInt(o, 10) - 1, parseInt(n, 10), parseInt(s, 10), parseInt(a, 10), parseInt(l || "0", 10)).getTime() } query(e) { var t = this; return Xt((function* () { const { range: r } = e, n = r.from.valueOf(), o = r.to.valueOf(); try { const r = e.targets.map(function () { var e = Xt((function* (e) { var r; if ("text" === e.queryType) { var i, s; let r, n = []; const o = null === (i = e.propertySelection) || void 0 === i ? void 0 : i.name, m = (null === (s = e.filterPropertySelection) || void 0 === s ? void 0 : s.name) || "status"; switch (o) { case "group": var a; r = yield t.api.getGroupInfo((null === (a = e.groupSelection) || void 0 === a ? void 0 : a.name) || "*"); const i = t.parsePRTGDateTime(r.datetime); var l; n = [{ name: "Time", type: h.FieldType.time, values: [i], config: {} }, { name: m, type: h.FieldType.string, values: [null !== (l = null == r ? void 0 : r[m]) && void 0 !== l ? l : ""], config: { displayName: `${r.group} - ${m}` } }]; break; case "device": var c; r = yield t.api.getDeviceInfo((null === (c = e.deviceSelection) || void 0 === c ? void 0 : c.name) || "*"); const s = t.parsePRTGDateTime(r.datetime); var u; n = [{ name: "Time", type: h.FieldType.time, values: [s], config: {} }, { name: m, type: h.FieldType.string, values: [null !== (u = null == r ? void 0 : r[m]) && void 0 !== u ? u : ""], config: { displayName: `${r.group} - ${r.device} - ${m}` } }]; break; case "sensor": var d; r = yield t.api.getSensorInfo((null === (d = e.sensorSelection) || void 0 === d ? void 0 : d.name) || "*"); const f = t.parsePRTGDateTime(r.datetime); var p; n = [{ name: "Time", type: h.FieldType.time, values: [f], config: {} }, { name: m, type: h.FieldType.string, values: [null !== (p = null == r ? void 0 : r[m]) && void 0 !== p ? p : ""], config: { displayName: `${r.group} - ${r.device} - ${r.sensor} -${m}` } }]; break; default: return console.warn("Unknown property type:", o), null }return (0, h.createDataFrame)({ refId: e.refId, name: `PRTG ${o} ${m}`, fields: n }) } if ("raw" === e.queryType) { var m, f; let r, n = []; const o = null === (m = e.propertySelection) || void 0 === m ? void 0 : m.name, i = (null === (f = e.filterPropertySelection) || void 0 === f ? void 0 : f.name) || "status_raw"; switch (o) { case "group": var g; r = yield t.api.getGroupInfo((null === (g = e.groupSelection) || void 0 === g ? void 0 : g.name) || "*"); const s = t.parsePRTGDateTime(r.datetime); var y; n = [{ name: "Time", type: h.FieldType.time, values: [s], config: {} }, { name: i, type: i.endsWith("_raw") ? h.FieldType.number : h.FieldType.string, values: [null !== (y = r[`${i}_raw`]) && void 0 !== y ? y : ""], config: { displayName: `${r.group} - ${i}` } }]; break; case "device": var b; r = yield t.api.getDeviceInfo((null === (b = e.deviceSelection) || void 0 === b ? void 0 : b.name) || "*"); const a = t.parsePRTGDateTime(r.datetime); var S; n = [{ name: "Time", type: h.FieldType.time, values: [a], config: {} }, { name: i, type: i.endsWith("_raw") ? h.FieldType.number : h.FieldType.string, values: [null !== (S = r[`${i}_raw`]) && void 0 !== S ? S : ""], config: { displayName: `${r.group} - ${r.device} - ${i}` } }]; break; case "sensor": var w; r = yield t.api.getSensorInfo((null === (w = e.sensorSelection) || void 0 === w ? void 0 : w.name) || "*"); const l = t.parsePRTGDateTime(r.datetime); var E; n = [{ name: "Time", type: h.FieldType.time, values: [l], config: {} }, { name: i, type: i.endsWith("_raw") ? h.FieldType.number : h.FieldType.string, values: [null !== (E = r[`${i}_raw`]) && void 0 !== E ? E : ""], config: { displayName: `${r.group} - ${r.device}- ${r.sensor}- ${i}` } }]; break; default: return console.warn("Unknown property type:", o), null }return (0, h.createDataFrame)({ refId: e.refId, name: `PRTG ${o} ${i}`, fields: n }) } if (!(null === (r = e.valueSelection) || void 0 === r ? void 0 : r.name)) return null; try { var T; const r = null === (T = e.sensorSelection) || void 0 === T ? void 0 : T.name; if (!r) return console.error("No sensor selected"), null; try { var O, P, R, N, L; const i = (yield t.api.getSensorInfo(r)).objid; if (!i) return console.error("Could not find sensor ID for:", r), null; const s = [{ sensorId: i, channelId: null === (O = e.channelSelection) || void 0 === O ? void 0 : O.name, name: null === (P = e.valueSelection) || void 0 === P ? void 0 : P.name }], a = (yield t.api.performQuerySuggestQuery(n, o, s)).histdata; if (!Array.isArray(a) || 0 === a.length) return console.error("No data points in response"), null; const l = a[0], c = Object.keys(l).filter((e => "datetime" !== e)), u = e.valueSelection.name.split(",").map((e => e.trim())).filter((e => c.includes(e))); 0 === u.length && u.push(...c); const d = a.map((e => t.parsePRTGDateTime(String(e.datetime)))), p = [{ name: "Time", type: h.FieldType.time, values: d, config: {} }]; u.forEach((t => { var r, n, o, i, s, l; const c = a.map((e => { const r = e[t], n = "number" == typeof r ? r : parseFloat(String(r)); return isNaN(n) ? null : n })).filter((e => null !== e)), u = []; (null === (r = e.options) || void 0 === r ? void 0 : r.includeGroupName) && (null === (n = e.groupSelection) || void 0 === n ? void 0 : n.name) && u.push(e.groupSelection.name), (null === (o = e.options) || void 0 === o ? void 0 : o.includeDeviceName) && (null === (i = e.deviceSelection) || void 0 === i ? void 0 : i.name) && u.push(e.deviceSelection.name), (null === (s = e.options) || void 0 === s ? void 0 : s.includeSensorName) && (null === (l = e.sensorSelection) || void 0 === l ? void 0 : l.name) && u.push(e.sensorSelection.name), u.push(t); const d = u.join(" - "); p.push({ name: t, type: h.FieldType.number, values: c, config: { displayName: d, custom: { drawStyle: "line", lineWidth: 1, pointSize: 5 } } }) })); const m = v()([null === (R = e.groupSelection) || void 0 === R ? void 0 : R.name, null === (N = e.deviceSelection) || void 0 === N ? void 0 : N.name, null === (L = e.sensorSelection) || void 0 === L ? void 0 : L.name]).compact().join(" - ") || "PRTG Data"; return (0, h.createDataFrame)({ refId: e.refId, name: m, fields: p }) } catch (e) { return console.error(`Failed to get sensor info for: ${r}`, e), null } } catch (t) { return console.error(`Query failed for target ${e.refId}:`, t), null } })); return function (t) { return e.apply(this, arguments) } }()), i = (yield Promise.all(r)).filter((e => null !== e)); return { data: i, state: i.length > 0 ? h.LoadingState.Done : h.LoadingState.Error } } catch (e) { return console.error("Query failed:", e), { data: [], state: h.LoadingState.Error } } }))() } testDatasource() { var e = this; return Xt((function* () { try { const t = yield e.api.getVersion(); return (yield e.api.testAuth()) ? { status: "success", message: `Successfully connected to PRTG ${t}`, details: { message: "Connected to PRTG server", verboseMessage: `Version: ${t}` } } : { status: "error", message: "Authentication failed", details: { message: "Failed to authenticate with PRTG server", verboseMessage: "Please check your credentials and try again" } } } catch (e) { return { status: "error", message: "Connection failed", details: { message: "Could not connect to PRTG server", verboseMessage: e instanceof Error ? e.message : "Unknown error" } } } }))() } constructor(e) { super(er(Yt({}, e), { type: tr.pluginId, id: "string" == typeof e.id ? parseInt(e.id, 10) : e.id || 0 })), Zt(this, "api", void 0), Zt(this, "templateSrv", void 0), Zt(this, "baseUrl", void 0), Zt(this, "username", void 0), Zt(this, "passhash", void 0), Zt(this, "annotations", { prepareQuery: e => { if (!e.annotation.sensorId) return; const t = { mode: { name: "Metrics", value: "Metrics", filterProperty: {}, valueSource: {}, valueProperty: {} }, includeGroupName: !1, includeSensorName: !1, includeDeviceName: !1, propertyName: { name: "", visible_name: "" }, filterPropertyName: { name: "", visible_name: "" }, target: e.annotation.sensorId.toString() }; return { refId: "annotations", queryType: "metrics", sensorSelection: { name: e.annotation.sensorId.toString() }, groupSelection: { name: "*" }, deviceSelection: { name: "*" }, channelSelection: { name: "*" }, propertySelection: { name: "" }, filterPropertySelection: { name: "" }, rawRequest: { endpoint: "", parameters: "" }, transformations: [], options: t, queryOptions: er(Yt({}, t), { displayMode: { name: "Metrics", value: "Metrics", filterProperty: {}, valueSource: {}, valueProperty: {} }, textProperty: { name: "", visible_name: "" } }) } } }), this.baseUrl = `https://${e.jsonData.hostname}/api/`, this.username = e.jsonData.username || "", this.passhash = e.jsonData.passhash || ""; const t = { baseUrl: `https://${e.jsonData.hostname}/api/`, username: e.jsonData.username || "", passwordHash: e.jsonData.passhash || "", cacheTimeout: this.parseTimeout(e.jsonData.cacheTimeout, 300), enableTimeZoneAdjust: e.jsonData.tzAutoAdjust || !1, useProxy: !0, timeout: this.parseTimeout(e.jsonData.timeout, 3e4) }; this.api = new Jt(t), this.templateSrv = (0, f.getTemplateSrv)() } } Zt(tr, "pluginId", "prtg-grafana-datasource"); var rr = c(959), nr = c.n(rr), or = c(7); function ir(e, t, r) { return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e } function sr(e) { for (var t = 1; t < arguments.length; t++) { var r = null != arguments[t] ? arguments[t] : {}, n = Object.keys(r); "function" == typeof Object.getOwnPropertySymbols && (n = n.concat(Object.getOwnPropertySymbols(r).filter((function (e) { return Object.getOwnPropertyDescriptor(r, e).enumerable })))), n.forEach((function (t) { ir(e, t, r[t]) })) } return e } function ar(e, t) { return t = null != t ? t : {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : function (e, t) { var r = Object.keys(e); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); t && (n = n.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), r.push.apply(r, n) } return r }(Object(t)).forEach((function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)) })), e } const lr = e => !(e.length < 2) && ("/" === e[0] && "/" === e[e.length - 1]), cr = e => !isNaN(parseFloat(e)) && isFinite(e), ur = e => "string" == typeof e && e.startsWith("$"); function dr(e, t, r, n, o, i, s) { try { var a = e[i](s), l = a.value } catch (e) { return void r(e) } a.done ? t(l) : Promise.resolve(l).then(n, o) } function pr(e) { return function () { var t = this, r = arguments; return new Promise((function (n, o) { var i = e.apply(t, r); function s(e) { dr(i, n, o, s, a, "next", e) } function a(e) { dr(i, n, o, s, a, "throw", e) } s(void 0) })) } } function mr(e, t, r) { return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e } class hr { init() { const e = this.target; this.templateSrv = this.templateSrv, this.targetLetters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; const t = { metric: { filterPropertyList: [{ name: "active", visible_name: "Active" }, { name: "message_raw", visible_name: "Message" }, { name: "priority", visible_name: "Priority" }, { name: "status", visible_name: "Status" }, { name: "tags", visible_name: "Tags" }], propertyList: [{ name: "group", visible_name: "Group" }, { name: "device", visible_name: "Device" }, { name: "sensor", visible_name: "Sensor" }] }, oldTarget: (0, g.cloneDeep)(this.target) }; Object.assign(this, t); const r = { group: { name: "" }, device: { name: "" }, sensor: { name: "" }, channel: { name: "" }, value: { name: "" }, raw: { uri: "", queryString: "" }, functions: [], options: { mode: this.queryTypeOptions[1], includeGroupName: !1, includeSensorName: !1, includeDeviceName: !1, filterPropertyName: { name: "", visible_name: "" }, propertyName: { name: "", visible_name: "" }, target: "*", deviceName: { name: "", visible_name: "" }, sensorName: { name: "", visible_name: "" }, groupName: { name: "", visible_name: "" }, invertChannelFilter: !1 }, queryOptions: { displayMode: this.queryTypeOptions[1], includeSensorName: !1, includeDeviceName: !1, includeGroupName: !1, filterPropertyName: { name: "", visible_name: "" }, propertyName: { name: "", visible_name: "" }, target: "*", textProperty: { name: "", visible_name: "" } } }; Object.assign(e, r), this.updateGroupList(), this.updateDeviceList(), this.updateSensorList(), this.updateChannelList(), this.updateValueList(), this.updatePropertyList(), this.updateFilterPropertyList(), this.target.validationErrors = this.validateTarget(), this.getGroupNames = () => this.getMetricNames("groupList") || [], this.getDeviceNames = () => this.getMetricNames("deviceList") || [], this.getSensorNames = () => this.getMetricNames("sensorList") || [], this.getChannelNames = () => this.getMetricNames("channelList") || [], this.getValueNames = () => this.getMetricNames("valueList") || [], this.getPropertyName = () => this.getMetricNames("propertyList") || [], this.getFilterPropertyName = () => this.getMetricNames("filterPropertyList") || [], this.metric.propertyList = [...this.scopeDefaults.metric.propertyList], this.metric.filterPropertyList = [...this.scopeDefaults.metric.filterPropertyList] } switchEditorMode(e) { this.target.options ? this.target.options.mode = e : this.target.options = { mode: e, includeSensorName: !1, includeDeviceName: !1, includeGroupName: !1, propertyName: { name: "", visible_name: "" }, filterPropertyName: { name: "", visible_name: "" }, target: "*" }, this.targetChange() } targetChange() { const e = (0, g.cloneDeep)(this.target); var t; this.isEqual(this.oldTarget, this.target) || (this.oldTarget = e, (null === (t = this.panelCtrl) || void 0 === t ? void 0 : t.refresh) && this.panelCtrl.refresh()) } variableChanged() { ["groupSelection", "deviceSelection", "sensorSelection", "channelSelection", "valueSelection", "propertySelection", "filterPropertySelection"].some((e => { const t = this.target[e]; return !!(t && t.name && t.name.indexOf("$") > -1) && (this.targetChange(), !0) })) } selectGroup() { this.targetChange(), this.updateDeviceList().catch((e => console.error("Failed to update device list:", e))) } selectDevice() { this.targetChange(), this.updateSensorList().catch((e => console.error("Failed to update sensor list:", e))) } selectSensor() { this.targetChange(), this.updateChannelList().catch((e => console.error("Failed to update channel list:", e))) } selectChannel() { this.targetChange(), this.updateValueList().catch((e => console.error("Failed to update value list:", e))) } selectValue() { this.targetChange() } selectProperty() { this.targetChange() } selectFilterProperty() { this.targetChange() } validateTarget() { var e, t, r, n, o, i; const s = []; if (!this.target) throw new Vt("Target is not defined"); const { groupSelection: a, deviceSelection: l, sensorSelection: c, channelSelection: u, valueSelection: d, propertySelection: p, filterPropertySelection: m } = this.target; return (null == a || null === (e = a.name) || void 0 === e ? void 0 : e.trim()) || s.push("Group selection is required"), (null == l || null === (t = l.name) || void 0 === t ? void 0 : t.trim()) || s.push("Device selection is required"), (null == c || null === (r = c.name) || void 0 === r ? void 0 : r.trim()) || s.push("Sensor selection is required"), (null == u || null === (n = u.name) || void 0 === n ? void 0 : n.trim()) || s.push("Channel selection is required"), (null == d || null === (o = d.name) || void 0 === o ? void 0 : o.trim()) || s.push("Value selection is required"), (null == p || null === (i = p.name) || void 0 === i ? void 0 : i.trim()) || s.push("Property selection is required"), m || (this.target.validationErrors = void 0), s } getMetricNames(e) { const t = this.metric[e]; if (Array.isArray(t)) return [...new Set(t.map((e => e.name)))] } updateTarget(e) { this.target = function (e) { for (var t = 1; t < arguments.length; t++) { var r = null != arguments[t] ? arguments[t] : {}, n = Object.keys(r); "function" == typeof Object.getOwnPropertySymbols && (n = n.concat(Object.getOwnPropertySymbols(r).filter((function (e) { return Object.getOwnPropertyDescriptor(r, e).enumerable })))), n.forEach((function (t) { mr(e, t, r[t]) })) } return e }({}, this.target, e) } addTemplatedVariables(e) { this.templateSrv.getVariables().forEach((t => { e.push({ name: "$" + t.name, templated: !0 }) })) } isEqual(e, t) { return !(!e || !t) && JSON.stringify(e) === JSON.stringify(t) } getTarget() { return this.target } updateGroupList() { var e = this; return pr((function* () { e.metric.groupList = [{ name: "*", visible_name: "All" }], e.addTemplatedVariables(e.metric.groupList); try { const t = yield e.datasource.api.performGroupSuggestQuery(); Array.isArray(t) && t.forEach((t => { (null == t ? void 0 : t.group) && e.metric.groupList.push({ name: t.group, visible_name: t.group }) })) } catch (e) { console.error("Failed to update group list:", e) } }))() } updateDeviceList() { var e = this; return pr((function* () { var t; if (!(null === (t = e.target.groupSelection) || void 0 === t ? void 0 : t.name)) return; const r = e.templateSrv.replace(e.target.groupSelection.name); e.metric.deviceList = [{ name: "*", visible_name: "All" }], e.addTemplatedVariables(e.metric.deviceList); try { const t = yield e.datasource.api.performDeviceSuggestQuery(r); Array.isArray(t) && t.forEach((t => { ((null == t ? void 0 : t.device) || (null == t ? void 0 : t.device)) && e.metric.deviceList.push({ name: t.device, visible_name: t.device }) })) } catch (e) { console.error("Failed to update device list:", e) } }))() } updateSensorList() { var e = this; return pr((function* () { var t; if (!(null === (t = e.target.deviceSelection) || void 0 === t ? void 0 : t.name)) return; const r = e.templateSrv.replace(e.target.deviceSelection.name); e.metric.sensorList = [{ name: "*", visible_name: "All" }], e.addTemplatedVariables(e.metric.sensorList); try { const t = yield e.datasource.api.performSensorSuggestQuery(r); Array.isArray(t) && t.forEach((t => { t.sensor && e.metric.sensorList.push({ name: t.sensor, visible_name: t.sensor }) })) } catch (e) { console.error("Failed to update sensor list:", e) } }))() } updateChannelList() { var e = this; return pr((function* () { var t; if (!(null === (t = e.target.sensorSelection) || void 0 === t ? void 0 : t.name)) return; const r = e.templateSrv.replace(e.target.groupSelection.name), n = e.templateSrv.replace(e.target.deviceSelection.name), o = e.templateSrv.replace(e.target.sensorSelection.name); e.metric.channelList = [{ name: "*", visible_name: "All" }], e.addTemplatedVariables(e.metric.channelList); try { const t = yield e.datasource.api.performChannelSuggestQuery(r, n, o); Array.isArray(t) && t.forEach((t => { const r = t.channel, n = t.channel; r && e.metric.channelList.push({ name: r.toString(), visible_name: (null == n ? void 0 : n.toString()) || r.toString() }) })) } catch (e) { console.error("Failed to update channel list:", e) } }))() } updateValueList() { var e = this; return pr((function* () { var t; if (!(null === (t = e.target.channelSelection) || void 0 === t ? void 0 : t.name)) return; const r = e.templateSrv.replace(e.target.groupSelection.name), n = e.templateSrv.replace(e.target.deviceSelection.name), o = e.templateSrv.replace(e.target.sensorSelection.name), i = e.templateSrv.replace(e.target.channelSelection.name); e.metric.valueList = [{ name: "*", visible_name: "All" }], e.addTemplatedVariables(e.metric.valueList); try { const t = yield e.datasource.api.performValueSuggestQuery(r, n, o, i); if (Array.isArray(t) && t.length > 0) { const r = t[0]; Object.keys(r).forEach((t => { "datetime" !== t && e.metric.valueList.push({ name: t, visible_name: t }) })) } } catch (e) { console.error("Failed to update value list:", e) } }))() } updatePropertyList() { this.metric.propertyList = [...this.scopeDefaults.metric.propertyList] } updateFilterPropertyList() { this.metric.filterPropertyList = [...this.scopeDefaults.metric.filterPropertyList] } getPropertyList() { return this.scopeDefaults.metric.propertyList } getQueryTypeOptions() { return Object.values(this.queryTypeOptions).map((e => ({ label: e.name, value: e.value, description: `${e.name} Mode` }))) } getMetricList(e) { switch (e) { case "group": return this.metric.groupList || []; case "device": return this.metric.deviceList || []; case "sensor": return this.metric.sensorList || []; case "channel": return this.metric.channelList || []; case "value": return this.metric.valueList || []; case "propertyList": return this.scopeDefaults.metric.propertyList || []; case "filterPropertyList": return this.scopeDefaults.metric.filterPropertyList || []; default: return [] } } clearSelection(e) { switch (e) { case "group": this.target.groupSelection = { name: "" }, this.metric.deviceList = [], this.metric.sensorList = [], this.metric.channelList = [], this.metric.valueList = [], this.metric.propertyList = [], this.metric.filterPropertyList = []; break; case "device": this.target.deviceSelection = { name: "" }, this.metric.sensorList = [], this.metric.channelList = [], this.metric.valueList = [], this.metric.propertyList = [], this.metric.filterPropertyList = []; break; case "sensor": this.target.sensorSelection = { name: "" }, this.metric.channelList = [], this.metric.valueList = [], this.metric.propertyList = [], this.metric.filterPropertyList = []; break; case "channel": this.target.channelSelection = { name: "" }, this.metric.valueList = []; case "value": this.target.valueSelection = { name: "" }; break; case "property": this.target.propertySelection = { name: "" }, this.metric.filterPropertyList = [] }this.targetChange() } refreshSelectionLists() { var e = this; return pr((function* () { var t, r, n, o, i; (yield e.updateGroupList(), null === (t = e.target.groupSelection) || void 0 === t ? void 0 : t.name) && (yield e.updateDeviceList(), (null === (r = e.target.deviceSelection) || void 0 === r ? void 0 : r.name) && (yield e.updateSensorList(), yield e.updatePropertyList(), (null === (n = e.target.sensorSelection) || void 0 === n ? void 0 : n.name) && (yield e.updateChannelList(), (null === (o = e.target.channelSelection) || void 0 === o ? void 0 : o.name) && (yield e.updateValueList(), (null === (i = e.target.valueSelection) || void 0 === i ? void 0 : i.name) && e.targetChange())))) }))() } getValidationStatus() { const e = this.validateTarget(); return { isValid: 0 === e.length, errors: e } } resetTarget() { this.target = { refId: this.getNextRefId(), queryType: "metrics", groupSelection: { name: "" }, deviceSelection: { name: "" }, sensorSelection: { name: "" }, channelSelection: { name: "" }, valueSelection: { name: "" }, propertySelection: { name: "" }, filterPropertySelection: { name: "" }, rawRequest: { endpoint: "", parameters: "" }, transformations: [], options: { mode: this.queryTypeOptions[1], includeSensorName: !1, includeDeviceName: !1, includeGroupName: !1, propertyName: { name: "", visible_name: "" }, filterPropertyName: { name: "", visible_name: "" }, target: "*", deviceName: { name: "", visible_name: "" }, sensorName: { name: "", visible_name: "" }, groupName: { name: "", visible_name: "" } }, queryOptions: { displayMode: this.queryTypeOptions[1], includeSensorName: !1, includeDeviceName: !1, includeGroupName: !1, filterPropertyName: { name: "", visible_name: "" }, propertyName: { name: "", visible_name: "" }, target: "*", textProperty: { name: "", visible_name: "" } } }, this.targetChange() } applyTemplateVariables(e) { return this.templateSrv.replace(e, {}, "regex") } dispose() { this.metric = { groupList: [], deviceList: [], sensorList: [], channelList: [], valueList: [], propertyList: [], filterPropertyList: [] } } getNextRefId() { var e; const t = this.targetLetters.split(""), r = (null === (e = this.target) || void 0 === e ? void 0 : e.refId) || "A", n = Math.max(0, t.indexOf(r)); return t[n] || "A" } constructor(e, t, r, n) { mr(this, "target", void 0), mr(this, "datasource", void 0), mr(this, "templateSrv", void 0), mr(this, "oldTarget", void 0), mr(this, "targetLetters", void 0), mr(this, "panelCtrl", void 0), mr(this, "queryTypeOptions", { 1: { name: "Metrics", value: "metrics", filterProperty: {}, valueSource: {}, valueProperty: {} }, 2: { name: "Text", value: "text", filterProperty: {}, valueSource: {}, valueProperty: {} }, 3: { name: "Raw", value: "raw", filterProperty: {}, valueSource: {}, valueProperty: {} } }), mr(this, "metric", void 0), mr(this, "scopeDefaults", { metric: { filterPropertyList: [{ name: "active", visible_name: "Active" }, { name: "message_raw", visible_name: "Message" }, { name: "priority", visible_name: "Priority" }, { name: "status", visible_name: "Status" }, { name: "tags", visible_name: "Tags" }], propertyList: [{ name: "group", visible_name: "Group" }, { name: "device", visible_name: "Device" }, { name: "sensor", visible_name: "Sensor" }] } }), mr(this, "isRegex", lr), mr(this, "isNumeric", cr), mr(this, "isVariable", ur), mr(this, "getGroupNames", (() => this.getMetricNames("groupList") || [])), mr(this, "getDeviceNames", (() => this.getMetricNames("deviceList") || [])), mr(this, "getSensorNames", (() => this.getMetricNames("sensorList") || [])), mr(this, "getChannelNames", (() => this.getMetricNames("channelList") || [])), mr(this, "getValueNames", (() => this.getMetricNames("valueList") || [])), mr(this, "getPropertyName", (() => this.getMetricNames("propertyList") || [])), mr(this, "getFilterPropertyName", (() => this.getMetricNames("filterPropertyList") || [])), this.target = e, this.datasource = t, this.templateSrv = r, this.targetLetters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ", this.panelCtrl = n, this.metric = { groupList: [], deviceList: [], sensorList: [], channelList: [], valueList: [], propertyList: [], filterPropertyList: [] }, this.init() } } function fr(e, t, r, n, o, i, s) { try { var a = e[i](s), l = a.value } catch (e) { return void r(e) } a.done ? t(l) : Promise.resolve(l).then(n, o) } function gr(e) { return function () { var t = this, r = arguments; return new Promise((function (n, o) { var i = e.apply(t, r); function s(e) { fr(i, n, o, s, a, "next", e) } function a(e) { fr(i, n, o, s, a, "throw", e) } s(void 0) })) } } function vr(e, t, r) { return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e } function yr(e) { for (var t = 1; t < arguments.length; t++) { var r = null != arguments[t] ? arguments[t] : {}, n = Object.keys(r); "function" == typeof Object.getOwnPropertySymbols && (n = n.concat(Object.getOwnPropertySymbols(r).filter((function (e) { return Object.getOwnPropertyDescriptor(r, e).enumerable })))), n.forEach((function (t) { vr(e, t, r[t]) })) } return e } function br(e, t) { return t = null != t ? t : {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : function (e, t) { var r = Object.keys(e); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); t && (n = n.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), r.push.apply(r, n) } return r }(Object(t)).forEach((function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)) })), e } const Sr = new h.DataSourcePlugin(tr).setConfigEditor((function (e) { const { onOptionsChange: t, options: r } = e, { jsonData: n } = r; return nr().createElement(nr().Fragment, null, nr().createElement("h1", null, "API Configuration:"), nr().createElement(or.InlineField, { label: "Hostname", labelWidth: 20, interactive: !0, tooltip: "Hostname for the API" }, nr().createElement(or.Input, { id: "config-editor-hostname", onChange: e => { t(ar(sr({}, r), { jsonData: ar(sr({}, n), { hostname: e.target.value }) })) }, value: n.hostname, placeholder: "Enter the hostname, e.g. yourserver", width: 40 })), nr().createElement(or.InlineField, { label: "Username", labelWidth: 20, interactive: !0, tooltip: "Username for the API" }, nr().createElement(or.Input, { id: "config-editor-username", onChange: e => { t(ar(sr({}, r), { jsonData: ar(sr({}, n), { username: e.target.value }) })) }, value: n.username, placeholder: "Enter the username, e.g. myuser", width: 40 })), nr().createElement(or.InlineField, { label: "Passhash", labelWidth: 20, interactive: !0, tooltip: "Passhash for the API" }, nr().createElement(or.Input, { id: "config-editor-passhash", onChange: e => { t(ar(sr({}, r), { jsonData: ar(sr({}, n), { passhash: e.target.value }) })) }, value: n.passhash, placeholder: "Enter your passhash", type: "password", width: 40 })), nr().createElement(or.InlineField, { label: "Cache Timeout", labelWidth: 20, interactive: !0, tooltip: "Cache timeout in seconds" }, nr().createElement(or.Input, { type: "number", id: "config-editor-cache-timeout", onChange: e => { const o = parseInt(e.target.value, 10); t(ar(sr({}, r), { jsonData: ar(sr({}, n), { cacheTimeout: o > 0 ? o : 300 }) })) }, value: n.cacheTimeout || 300, placeholder: "Enter cache timeout in seconds", width: 40 }))) })).setQueryEditor((function ({ query: e, onChange: t, onRunQuery: r, datasource: n }) { var o, i, s, a, l, c, u, d, p, m, h, f, g, v, y, b, S, w, E, T, O, P; const [R] = (0, rr.useState)((() => new hr(e, n, n.templateSrv, { refresh: r }))), [N, L] = (0, rr.useState)({ groups: [], devices: [], sensors: [], channels: [], values: [], properties: [], filterProperties: [] }); (0, rr.useEffect)((() => (j(), () => R.dispose())), []); const j = function () { var e = gr((function* () { yield R.refreshSelectionLists(), C() })); return function () { return e.apply(this, arguments) } }(), C = () => { try { const e = e => (R.getMetricList(e) || []).map((e => ({ label: e.visible_name || e.name, value: e.name }))); L({ groups: e("group"), devices: e("device"), sensors: e("sensor"), channels: e("channel"), values: e("value"), properties: e("propertyList"), filterProperties: e("filterPropertyList") }) } catch (e) { console.error("Error updating select lists:", e), L({ groups: [], devices: [], sensors: [], channels: [], values: [], properties: [], filterProperties: [] }) } }, D = function () { var e = gr((function* (e) { R.updateTarget({ groupSelection: { name: e.value || "" }, options: br(yr({}, k.options), { groupName: { name: e.value || "", visible_name: e.label || "" } }) }), R.selectGroup(), C(), t(R.getTarget()), r() })); return function (t) { return e.apply(this, arguments) } }(), A = function () { var e = gr((function* (e) { R.updateTarget({ deviceSelection: { name: e.value || "" }, options: br(yr({}, k.options), { deviceName: { name: e.value || "", visible_name: e.label || "" } }) }), R.selectDevice(), C(), t(R.getTarget()), r() })); return function (t) { return e.apply(this, arguments) } }(), F = function () { var e = gr((function* (e) { R.updateTarget({ sensorSelection: { name: e.value || "" }, options: br(yr({}, k.options), { sensorName: { name: e.value || "", visible_name: e.label || "" } }) }), R.selectSensor(), C(), t(R.getTarget()), r() })); return function (t) { return e.apply(this, arguments) } }(), _ = function () { var e = gr((function* (e) { R.updateTarget({ channelSelection: { name: e.value || "" } }), R.selectChannel(), C(), t(R.getTarget()), r() })); return function (t) { return e.apply(this, arguments) } }(), x = function () { var e = gr((function* (e) { const n = Array.isArray(e) ? e.map((e => e.value)).join(",") : (null == e ? void 0 : e.value) || ""; R.updateTarget({ valueSelection: { name: n } }), R.selectValue(), C(), t(R.getTarget()), r() })); return function (t) { return e.apply(this, arguments) } }(), I = R.getQueryTypeOptions(), k = R.getTarget(), U = "metrics" === k.queryType, q = "raw" === k.queryType, M = "text" === k.queryType; return nr().createElement(or.Stack, { direction: "column", gap: 1 }, nr().createElement(or.Stack, { direction: "row", gap: 4 }, nr().createElement(or.Stack, { direction: "column", gap: 1 }, nr().createElement(or.InlineField, { label: "Query Type", labelWidth: 20, grow: !0 }, nr().createElement(or.Select, { options: I, value: k.queryType, onChange: e => { R.updateTarget({ queryType: e.value, options: br(yr({}, k.options), { mode: { name: e.value, value: e.value, filterProperty: {}, valueSource: {}, valueProperty: {} } }) }), t(R.getTarget()), r() }, width: 47 })), nr().createElement(or.InlineField, { label: "Group", labelWidth: 20, grow: !0 }, nr().createElement(or.Select, { isLoading: !N.groups.length, options: N.groups, value: null === (o = k.groupSelection) || void 0 === o ? void 0 : o.name, onChange: D, width: 47, allowCustomValue: !0, isClearable: !0, isDisabled: !k.queryType, placeholder: "Select Group or type '*'" })), nr().createElement(or.InlineField, { label: "Device", labelWidth: 20, grow: !0 }, nr().createElement(or.Select, { isLoading: !N.devices.length, options: N.devices, value: null === (i = k.deviceSelection) || void 0 === i ? void 0 : i.name, onChange: A, width: 47, allowCustomValue: !0, placeholder: "Select Device or type '*'", isClearable: !0, isDisabled: !(null === (s = k.groupSelection) || void 0 === s ? void 0 : s.name) }))), nr().createElement(or.Stack, { direction: "column", gap: 1 }, nr().createElement(or.InlineField, { label: "Sensor", labelWidth: 20, grow: !0 }, nr().createElement(or.Select, { isLoading: !N.sensors.length, options: N.sensors, value: null === (a = k.sensorSelection) || void 0 === a ? void 0 : a.name, onChange: F, width: 47, allowCustomValue: !0, placeholder: "Select Sensor or type '*'", isClearable: !0, isDisabled: !(null === (l = k.deviceSelection) || void 0 === l ? void 0 : l.name) })), nr().createElement(or.InlineField, { label: "Channel Count", labelWidth: 20, grow: !0 }, nr().createElement(or.Select, { isLoading: !!U && !N.values.length, options: N.channels, value: null === (c = k.channelSelection) || void 0 === c ? void 0 : c.name, onChange: _, width: 47, allowCustomValue: !0, placeholder: "Select Channel or type '*'", isClearable: !0, isDisabled: !(null === (u = k.sensorSelection) || void 0 === u ? void 0 : u.name) || !U })), nr().createElement(or.InlineField, { label: "Channels", labelWidth: 20 }, nr().createElement(or.Select, { isLoading: !!U && !N.values.length, options: N.values, value: null === (d = k.valueSelection) || void 0 === d ? void 0 : d.name, onChange: x, placeholder: 'Select Channel or type "*"', isClearable: !0, isMulti: !0, width: 47, isDisabled: !(null === (p = k.channelSelection) || void 0 === p ? void 0 : p.name) || q || M })))), nr().createElement(or.FieldSet, { label: "Options" }, !U && nr().createElement(or.Stack, { direction: "row", gap: 2 }, nr().createElement(or.InlineField, { label: "Property", labelWidth: 20 }, nr().createElement(or.Select, { width: 47, value: { label: (null === (h = k.options) || void 0 === h || null === (m = h.propertyName) || void 0 === m ? void 0 : m.visible_name) || (null === (f = k.propertySelection) || void 0 === f ? void 0 : f.name), value: (null === (g = k.propertySelection) || void 0 === g ? void 0 : g.name) || "" }, isDisabled: !(null === (v = k.sensorSelection) || void 0 === v ? void 0 : v.name), onChange: e => { R.updateTarget({ propertySelection: { name: e.value || "" }, options: br(yr({}, k.options), { propertyName: { name: e.value || "", visible_name: e.label || "" } }) }), C(), t(R.getTarget()), r() }, options: N.properties, placeholder: "Select Property" })), nr().createElement(or.InlineField, { label: "Filter Property", labelWidth: 20 }, nr().createElement(or.Select, { width: 47, value: { label: (null === (b = k.options) || void 0 === b || null === (y = b.filterPropertyName) || void 0 === y ? void 0 : y.visible_name) || (null === (S = k.filterPropertySelection) || void 0 === S ? void 0 : S.name), value: (null === (w = k.filterPropertySelection) || void 0 === w ? void 0 : w.name) || "" }, isDisabled: !(null === (E = k.sensorSelection) || void 0 === E ? void 0 : E.name), onChange: e => { R.updateTarget({ filterPropertySelection: { name: e.value || "" }, options: br(yr({}, k.options), { filterPropertyName: { name: e.value || "", visible_name: e.label || "" } }) }), C(), t(R.getTarget()), r() }, options: N.filterProperties, placeholder: "Select Filter Property" }))), U && nr().createElement(or.Stack, { direction: "row", gap: 1 }, nr().createElement(or.InlineField, { label: "Include Group", labelWidth: 16 }, nr().createElement(or.InlineSwitch, { value: (null === (T = k.options) || void 0 === T ? void 0 : T.includeGroupName) || !1, onChange: e => { R.updateTarget({ options: br(yr({}, k.options), { includeGroupName: e.currentTarget.checked }) }), t(R.getTarget()), r() } })), nr().createElement(or.InlineField, { label: "Include Device", labelWidth: 15 }, nr().createElement(or.InlineSwitch, { value: (null === (O = k.options) || void 0 === O ? void 0 : O.includeDeviceName) || !1, onChange: e => { R.updateTarget({ options: br(yr({}, k.options), { includeDeviceName: e.currentTarget.checked }) }), t(R.getTarget()), r() } })), nr().createElement(or.InlineField, { label: "Include Sensor", labelWidth: 15 }, nr().createElement(or.InlineSwitch, { value: (null === (P = k.options) || void 0 === P ? void 0 : P.includeSensorName) || !1, onChange: e => { R.updateTarget({ options: br(yr({}, k.options), { includeSensorName: e.currentTarget.checked }) }), t(R.getTarget()), r() } }))))) })); return u })()));
//# sourceMappingURL=module.js.map